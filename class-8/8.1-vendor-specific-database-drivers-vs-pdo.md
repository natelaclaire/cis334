---
layout: default
title: 8.1 Vendor-specific DB drivers vs PDO
nav_order: 1
---

# 8.1 Vendor-specific DB drivers vs PDO

## 1) Why this matters

Today we move from writing SQL to actually accessing relational databases securely from PHP. You’ll learn the common options for connecting PHP to databases, why portability matters (or doesn’t), and how to choose the right tool for the job.

---

## 2) Quick inventory — common vendor-specific drivers in PHP

* **MySQLi** (`mysqli`) — MySQL-specific; two APIs: procedural and OOP; supports prepared statements, transactions, multi-query.
* **pgsql** (PostgreSQL extension) — `pg_connect`, `pg_query`, `pg_prepare`, `pg_execute`, etc.
* **sqlsrv / pdo_sqlsrv** — Microsoft SQL Server (on Windows/Linux with Microsoft drivers).
* **oci8** — Oracle database extension.
* **sqlite3** — SQLite extension (also available through PDO as `pdo_sqlite`).
* **PDO** — not a vendor driver, but a *uniform* abstraction layer with driver implementations (e.g., `pdo_mysql`, `pdo_pgsql`, `pdo_sqlite`).

---

## 3) The transition from MySQL to MySQLi

The original **MySQL extension** (functions like `mysql_connect()`, `mysql_query()`, `mysql_fetch_array()`) was introduced in PHP 2 and used for over a decade. However, it became **deprecated in PHP 5.5** and **removed entirely in PHP 7.0** for several important reasons:

| Limitation (old `mysql_*`)                                                             | Improvement with `MySQLi`                                                          |
| -------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| Did **not support prepared statements** → vulnerable to SQL injection.                 | MySQLi supports true prepared statements (both procedural & OO).                   |
| **No support for transactions** or multiple statements.                                | MySQLi supports transactions and `multi_query()`.                                  |
| Only **procedural** style; couldn’t be integrated cleanly in OOP code.                 | MySQLi supports both procedural **and** object-oriented syntax.                    |
| Could not use **MySQL 4.1+ features** like character sets and enhanced authentication. | MySQLi was built to handle all modern MySQL features.                              |
| No error reporting via exceptions; difficult debugging.                                | MySQLi can report errors more robustly and supports exceptions when used with PDO. |

In short:

> The **MySQLi (“MySQL improved”)** extension replaced the legacy MySQL extension to support modern features like prepared statements, transactions, and secure authentication.
>
> **If your textbook shows `mysql_connect()` or `mysql_query()`, you must use `mysqli_connect()` or PDO instead** — because the legacy extension no longer exists in PHP 7 and newer.

Here's a quick side-by-side example:

**Old (no longer valid in PHP 7+):**

```php
// Legacy - removed in PHP 7
$conn = mysql_connect('localhost', 'user', 'pass');
mysql_select_db('example', $conn);
$result = mysql_query("SELECT * FROM users");
```

**Modern equivalent using MySQLi:**

```php
$conn = mysqli_connect('localhost', 'user', 'pass', 'example');
$result = mysqli_query($conn, "SELECT * FROM users");
```

**Better yet (secure, modern PDO):**

```php
$pdo = new PDO("mysql:host=localhost;dbname=example;charset=utf8mb4", "user", "pass");
$stmt = $pdo->query("SELECT * FROM users");
```

So the takeaway for your students:

* The *legacy MySQL extension* is gone — any code using it will throw fatal errors in current PHP.
* Use **MySQLi** if you only plan to work with MySQL.
* Use **PDO** if you want flexibility across databases or object-oriented consistency.

---

## 4) What is PDO?

* **PHP Data Objects (PDO)** is a database-abstraction layer: a single, consistent API for many database systems.
* PDO **does not** emulate every feature of every DB — vendor-specific features still require vendor drivers or SQL dialects.
* PDO offers:

  * Consistent API for connections, prepared statements, transactions.
  * Named and positional parameters in prepared statements.
  * Support for many drivers (MySQL, PostgreSQL, SQLite, SQL Server, Oracle via drivers).
  * Configurable error modes (exceptions, warnings, silent).
  * Prepared statement emulation option (can be disabled to use native prepared statements).

---

## 5) Key pros and cons — vendor-specific drivers vs PDO

### Pros of vendor-specific drivers

* Access to vendor-specific features / extensions (e.g., `mysqli_multi_query`, MySQL-specific management tools).
* Sometimes slightly better performance for some operations (micro-benchmarks vary).
* Familiar/idiomatic API for that database (e.g., `pg_*` functions for PostgreSQL).
* May expose features not available in PDO driver.

### Cons of vendor-specific drivers

* **Non-portable** — code is tied to one DB API.
* More code duplication if you need to support multiple backends.
* Different error handling and parameter binding per driver.

### Pros of PDO

* **Single API** across multiple DBs — easier to write portable code.
* Cleaner prepared-statement interface and consistent error handling (exceptions).
* Easier to swap databases in apps (only DSN and small SQL tweaks needed).
* Good for OO codebases and modern PHP style.

### Cons of PDO

* Not all vendor-specific features available through PDO interface.
* Some drivers may use emulated prepared statements by default (configurable).
* Slight surface-level learning curve for driver-specific optimizations.

**Rule of thumb:** Use PDO in most app-level code for portability, security, and consistency. Use vendor-specific driver **only** when you need vendor-only features or proven driver-specific performance or tooling.

---

## 6) Security and best practices (applies to both)

* Always use **prepared statements** (parameterized queries) to prevent SQL injection.
* Set proper character encoding (use `charset=utf8mb4` for MySQL).
* Use transactions for multi-step operations.
* Prefer exceptions for error handling (makes failures easier to catch).
* Never interpolate raw user input into SQL strings.

---

## 7) Example code — same task in three ways

Below: connect, run a prepared SELECT, and an INSERT with bound params.

### A. MySQLi (OOP style)

```php
<?php
// mysqli_oop_example.php
$host = '127.0.0.1';
$user = 'dbuser';
$pass = 'dbpass';
$db   = 'example';

$mysqli = new mysqli($host, $user, $pass, $db);
if ($mysqli->connect_errno) {
    die("Connect failed: " . $mysqli->connect_error);
}
$mysqli->set_charset('utf8mb4');

// Prepared SELECT
$stmt = $mysqli->prepare("SELECT id, username, email FROM users WHERE status = ?");
$status = 'active';
$stmt->bind_param('s', $status); // 's' = string
$stmt->execute();
$result = $stmt->get_result();
while ($row = $result->fetch_assoc()) {
    echo $row['id'] . ": " . $row['username'] . " - " . $row['email'] . PHP_EOL;
}
$stmt->close();

// Prepared INSERT
$ins = $mysqli->prepare("INSERT INTO users (username, email, status) VALUES (?, ?, ?)");
$username = 'maria';
$email = 'maria@example.com';
$status = 'active';
$ins->bind_param('sss', $username, $email, $status);
$ins->execute();
echo "Inserted id: " . $ins->insert_id . PHP_EOL;
$ins->close();

$mysqli->close();
```

Notes: `bind_param` requires explicit type string (e.g., `i` integer, `s` string). `mysqli` allows `multi_query` and some MySQL-specific operations.

---

### B. PDO (MySQL) — recommended for portability

```php
<?php
// pdo_mysql_example.php
$host = '127.0.0.1';
$db   = 'example';
$user = 'dbuser';
$pass = 'dbpass';
$dsn  = "mysql:host=$host;dbname=$db;charset=utf8mb4";

$options = [
    PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION, // exceptions on errors
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    PDO::ATTR_EMULATE_PREPARES   => false, // use native prepares when possible
];

try {
    $pdo = new PDO($dsn, $user, $pass, $options);
} catch (PDOException $e) {
    die("DB connection failed: " . $e->getMessage());
}

// SELECT with positional params
$stmt = $pdo->prepare("SELECT id, username, email FROM users WHERE status = ?");
$stmt->execute(['active']);
$rows = $stmt->fetchAll();
foreach ($rows as $row) {
    echo "{$row['id']}: {$row['username']} - {$row['email']}\n";
}

// INSERT with named params
$ins = $pdo->prepare("INSERT INTO users (username, email, status) VALUES (:username, :email, :status)");
$ins->execute([
    ':username' => 'maria',
    ':email'    => 'maria@example.com',
    ':status'   => 'active',
]);
echo "Inserted id: " . $pdo->lastInsertId() . PHP_EOL;
```

Notes: switching to SQLite only requires changing DSN (and minor SQL differences if any). Error mode exceptions help debugging.

---

### C. PDO (SQLite) — same code, different DSN

```php
<?php
// pdo_sqlite_example.php
$db   = 'example.db';
$dsn  = "sqlite:$db"; // sqlite DSN

$options = [
    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
];

try {
    $pdo = new PDO($dsn, $user, $pass, $options);
} catch (PDOException $e) {
    die("DB connection failed: " . $e->getMessage());
}

// Usage identical to PDO MySQL examples above
```

---

## 8) Demonstration ideas (in-class)

* Demo 1: Run the **mysqli** example and show `bind_param` types and `multi_query`.
* Demo 2: Run the **PDO** example, then switch DSN to `sqlite:` and run again (quickly show portability).
* Demo 3: Show what happens when `ATTR_EMULATE_PREPARES` is `true` vs `false` (e.g., try binding a LIMIT param where a DB may not allow it).

---

## 9) When to choose which approach (decision checklist)

* Need multi-DB support or might change DB later? → **Use PDO**.
* Need vendor-specific features (e.g., MySQL multi-query, special server-side prepared statement behavior, driver-specific bulk APIs)? → **Consider vendor-specific driver**.
* Building a framework or library to be shipped for many DBs? → **PDO** or an abstraction built on PDO.
* Optimizing a hot path where micro-optimizations matter and vendor driver shows measurable benefit? → **Profile** first; then consider vendor driver if needed.

---

## 10) Short classroom assignment (recommended)

1. **Exercise**: Provide a simple `users` table. Implement two scripts: `list_users_mysqli.php` and `list_users_pdo.php`. Both should:

   * Connect to DB,
   * Use prepared statements to fetch active users,
   * Display results as an HTML table.
2. **Follow-up**: Replace MySQL with SQLite for the PDO script by changing DSN and minor SQL; verify it runs unchanged except for DSN.
3. **Challenge**: Add a transactional operation (transfer credits between two users) and implement it with PDO using `beginTransaction()` / `commit()` / `rollBack()`.

---

## 11) Common gotchas & debugging tips

* **Character encoding**: always specify `charset=utf8mb4` for MySQL to avoid corrupted emoji/4-byte UTF-8 characters.
* **Error modes**: set PDO to `ERRMODE_EXCEPTION` — otherwise silent failures are painful.
* **Emulated prepares**: `ATTR_EMULATE_PREPARES = true` may change behavior — prefer `false` to force native prepares where supported.
* **Binding integers**: PDO will often handle types; `bindValue()` can accept explicit PDO::PARAM_INT when necessary.
* **SQL dialects**: portability is helped by PDO, but SQL features (e.g., `ON DUPLICATE KEY UPDATE` in MySQL) are DB-specific.

---

## 12) Additional resources

* PHP Manual pages:
  * [`mysqli`](https://www.php.net/manual/en/book.mysqli.php) - MySQLi extension
  * [`sqlite`](https://www.php.net/manual/en/book.sqlite3.php) - SQLite extension
  * [`pgsql`](https://www.php.net/manual/en/book.pgsql.php) - PostgreSQL extension
  * [`odbc`](https://www.php.net/manual/en/book.uodbc.php) - ODBC extension
  * [`PDO`](https://www.php.net/manual/en/book.pdo.php) - PHP Data Objects
  * [`PDO Drivers`](https://www.php.net/manual/en/pdo.drivers.php) - list of available PDO drivers
* Tutorials:
  * [PHP: PDO Tutorial](https://phpdelusions.net/pdo) - comprehensive guide to using PDO
  * [PHP: MySQLi Tutorial](https://www.php.net/manual/en/mysqli.quickstart.php) - quickstart for MySQLi

---

## 13) Closing summary

Vendor-specific drivers give you access to special features and sometimes slightly improved performance for that database but tie your code to a single DB. PDO gives you a single, modern API for many databases, consistent error handling, and safer prepared statement usage — making it the recommended default for application code unless you need a vendor-only capability. In short: prefer PDO for application-level code; use vendor drivers only when you need what PDO can’t provide.
