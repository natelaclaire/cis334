---
layout: default
title: 8.3 Connecting & Querying with MySQLi (OOP style)
nav_order: 3
---

# 8.3 Connecting & Querying with **MySQLi (OOP style)**

## 1) Goal for today

* Establish a **safe, reliable connection** to MySQL using MySQLi OOP.
* Run **simple queries** and **prepared statements**.
* Handle **errors and exceptions** correctly.
* Use different **fetch options**.
* Properly **free results** and **close** things.

> Why this matters: It directly supports our outcomes around secure data access, preventing SQL injection, and writing maintainable, object-oriented PHP.

---

## 2) Recommended defaults

* Use **OOP** style: `$conn = new mysqli(...)`.
* Immediately enable **exceptions** for MySQLi: `mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);`
* Set **UTF-8** correctly: `$conn->set_charset('utf8mb4');`
* Prefer **prepared statements** for any user input.

---

## 3) Minimal connection (with robust error handling)

```php
<?php
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT); // throw exceptions on errors

$host = 'db';
$user = 'mariadb';
$pass = 'mariadb';
$db   = 'mydb';

try {
    $conn = new mysqli($host, $user, $pass, $db);
    $conn->set_charset('utf8mb4'); // full Unicode support
    // Optional: $conn->options(MYSQLI_OPT_INT_AND_FLOAT_NATIVE, 1);
    echo "Connected.\n";
} catch (mysqli_sql_exception $e) {
    // Never echo sensitive creds; log details server-side if needed
    die("Database connection failed.");
}
```

**Notes**

* With `mysqli_report(...STRICT)`, **connection/query errors throw exceptions**; catch them once instead of sprinkling `if (!$conn)` everywhere.
* If you *don’t* enable exceptions, you must check `$conn->connect_error`, `$conn->errno`, `$conn->error` manually after each call—more boilerplate, easier to miss.
* [MYSQLI_OPT_INT_AND_FLOAT_NATIVE](https://www.php.net/manual/en/mysqli.constants.php#constant.mysqli-opt-int-and-float-native) makes numeric columns return as PHP `int`/`float` instead of `string` (optional, but often useful).

---

## 4) Simple (non-prepared) queries — reads & writes

```php
// READ (no user input involved)
$sql = "SELECT * FROM `odometer_readings` LEFT JOIN vehicles on vehicles.vehicle_id=odometer_readings.vehicle_id ORDER BY reading_date DESC";
$result = $conn->query($sql);         // mysqli_result
$rows   = $result->fetch_all(MYSQLI_ASSOC);  // requires mysqlnd
$result->free();                       // free memory when done

// WRITE (INSERT/UPDATE/DELETE)
$ins = "INSERT INTO odometer_readings (vehicle_id, reading_date, odometer, source, notes) VALUES (1, '2025-01-01', 2500, 'manual', 'after trip to NYC')";
$conn->query($ins);
echo "Inserted ID: " . $conn->insert_id . PHP_EOL;
echo "Affected rows: " . $conn->affected_rows . PHP_EOL;
```

**When are simple queries OK?**

* Fine for **static** SQL (no user input).
* The moment user input is involved → **prepared statements**.

---

### **What is mysqlnd (MySQL Native Driver)?**

**mysqlnd** stands for **MySQL Native Driver** — it’s the PHP-native client library that lets extensions like **MySQLi** and **PDO_MySQL** communicate directly with MySQL.

Before mysqlnd existed, PHP relied on **libmysqlclient**, an external C library provided by MySQL itself. Starting with PHP 5.4, mysqlnd became the **default and recommended** driver.

#### **Key differences**

| Feature             | **mysqlnd** (modern, default)                                                                                     | **libmysqlclient** (legacy alternative) |
| ------------------- | ----------------------------------------------------------------------------------------------------------------- | --------------------------------------- |
| **Origin**          | Built into PHP itself                                                                                             | Separate external library from MySQL    |
| **Compatibility**   | Designed for MySQLi, PDO_MySQL, and old mysql_*                                                                   | Used by older MySQL extensions          |
| **Memory use**      | Uses PHP’s own memory manager — lighter footprint                                                                 | Separate allocator; less efficient      |
| **Feature support** | Enables `get_result()`, `fetch_all()`, asynchronous queries, `fetch_object()` improvements, and native statistics | Lacks those PHP-specific features       |
| **Installation**    | Included automatically in modern PHP builds                                                                       | Must be compiled manually (obsolete)    |
| **Recommended?**    | ✅ Yes — default since PHP 5.4                                                                                     | ❌ Deprecated / not needed anymore       |

#### **In practical terms**

* If you can call `$stmt->get_result()` or `$result->fetch_all()` in MySQLi, you already have **mysqlnd**.
* Without it, you must use `bind_result()` + `fetch()` loops to retrieve data from prepared statements.
* You almost never need to install anything — every current PHP build includes mysqlnd by default.

---

## 5) Prepared statements (secure & fast)

### Parameter types for `bind_param()`

* `i` → integer
* `d` → double (float)
* `s` → string
* `b` → blob (binary)

### Example (safe SELECT)

```php
// Task: get users by source + min_id, both supplied by user
$source = $_GET['source'] ?? 'manual';
$minId  = (int)($_GET['min'] ?? 1);

$stmt = $conn->prepare(
    "SELECT reading_id, vehicle_models.make, vehicle_models.model, odometer, reading_date
     FROM odometer_readings
     LEFT JOIN vehicles ON vehicles.vehicle_id = odometer_readings.vehicle_id
     LEFT JOIN vehicle_models ON vehicle_models.model_id = vehicles.model_id
     WHERE source = ? AND reading_id >= ?
     ORDER BY reading_date DESC"
);
$stmt->bind_param("si", $source, $minId); // s = string, i = integer
$stmt->execute();

// Option A: get_result() (requires mysqlnd)
$result = $stmt->get_result();
while ($row = $result->fetch_assoc()) {
    echo "{$row['reading_id']}: {$row['make']} {$row['model']} {$row['odometer']} {$row['reading_date']}<br>";
}
$result->free();
$stmt->close();
```

### Alternative fetch (no mysqlnd): `bind_result() + fetch()`

```php
$stmt = $conn->prepare("SELECT reading_id, vehicle_models.make, vehicle_models.model, odometer, reading_date
     FROM odometer_readings
     LEFT JOIN vehicles ON vehicles.vehicle_id = odometer_readings.vehicle_id
     LEFT JOIN vehicle_models ON vehicle_models.model_id = vehicles.model_id
     WHERE source = ? AND reading_id >= ?
     ORDER BY reading_date DESC");
$stmt->bind_param("si", $source, $minId);
$stmt->execute();
$stmt->bind_result($id, $make, $model, $odometer, $reading_date);
while ($stmt->fetch()) {
    echo "$id: $make $model $odometer $reading_date<br>";
}
$stmt->close();
```

### Prepared INSERT/UPDATE with transaction (and rollback on failure)

```php
try {
    $conn->begin_transaction(); // start

    $stmt = $conn->prepare(
        "INSERT INTO vendors (name, type, phone, city, state) VALUES (?, ?, ?, ?, ?)"
    );
    $name = "Auto Parts Co";
    $type = "supplier";
    $phone = "123-456-7890";
    $city = "New York";
    $state = "NY";
    $stmt->bind_param("sssss", $name, $type, $phone, $city, $state);
    $stmt->execute();
    $stmt->close();

    // maybe more statements here ...

    $conn->commit(); // all good
} catch (mysqli_sql_exception $e) {
    $conn->rollback(); // revert all changes
    // In production, log $e->getCode(), $e->getMessage()
    echo "Transaction failed; changes rolled back.";
}
```

---

## 6) Fetch options (reads)

Assume `$result = $conn->query("SELECT name, type, phone FROM vendors");`

* **Associative row**

  ```php
  while ($row = $result->fetch_assoc()) { /* $row['name'] */ }
  ```
* **Numeric row**

  ```php
  while ($row = $result->fetch_row()) { /* $row[0] */ }
  ```
* **Both**

  ```php
  while ($row = $result->fetch_array(MYSQLI_BOTH)) { /* $row['name'] or $row[0] */ }
  ```
* **All at once** (mysqlnd)

  ```php
  $rows = $result->fetch_all(MYSQLI_ASSOC);
  ```
* **Iterate directly**

  ```php
  foreach ($result as $row) { /* associative by default when mysqlnd is present */ }
  ```

**Other handy properties/methods**

* `$result->num_rows` — number of rows in the result set
* `$result->data_seek($n)` — jump the internal pointer to row `n`
* `$conn->insert_id` — last AUTO_INCREMENT value
* `$conn->affected_rows` — rows changed by the last write

---

## 7) Error handling patterns (three levels)

**A. Best (exceptions enabled once)**

```php
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);
try {
    $conn = new mysqli($host, $user, $pass, $db);
    $conn->set_charset('utf8mb4');
    $conn->query("BAD SQL"); // will throw mysqli_sql_exception
} catch (mysqli_sql_exception $e) {
    echo "DB Error: " . $e->getMessage();
}
```

**B. Manual checks (exceptions OFF)**
Use **only** if you can’t enable exceptions:

```php
$conn = new mysqli($host, $user, $pass, $db);
if ($conn->connect_errno) { die("Connect error: " . $conn->connect_error); }

$result = $conn->query($sql);
if ($result === false) {
    echo "Query error [{$conn->errno}]: {$conn->error}";
}
```

**C. Statement-level errors**

```php
$stmt = $conn->prepare("SELECT * FROM users WHERE id = ?");
if (!$stmt) {
    echo "Prepare failed [{$conn->errno}]: {$conn->error}";
}
```

> Tip: In real apps, **log** `$e->getCode()` and `$e->getMessage()`; show students safe, generic messages.

---

## 8) Freeing results & closing resources

* **Result sets:** `$result->free();`
* **Statements:** `$stmt->close();`
* **Connections:** `$conn->close();`
* Large arrays: `unset($rows);` to free memory sooner in long-lived scripts.

> Order isn’t ultra-strict, but free what you’re done with. PHP’s GC will clean up at the end of request, yet explicit frees help memory in loops/long scripts.

---

## 9) Putting it all together (copy-paste demo)

```php
<?php
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);

$host = 'db';
$user = 'mariadb';
$pass = 'mariadb';
$db   = 'mydb';

try {
    $conn = new mysqli($host, $user, $pass, $db);
    $conn->set_charset('utf8mb4');

    // Simple read (no user input)
    $result = $conn->query("SELECT vendor_id, name, type, phone FROM vendors ORDER BY name");
    $vendors = $result->fetch_all(MYSQLI_ASSOC);
    $result->free();

    // Prepared read (user input)
    $vehicle_id = 2;
    $stmt = $conn->prepare("SELECT total_amount, fuel_grade, purchase_datetime FROM fuel_purchases WHERE vehicle_id = ?");
    $stmt->bind_param("i", $vehicle_id);
    $stmt->execute();
    $res = $stmt->get_result();
    $purchases = $res->fetch_all(MYSQLI_ASSOC);
    $res->free();
    $stmt->close();

    // Transactional write
    $conn->begin_transaction();
    $stmt = $conn->prepare("INSERT INTO drivers (first_name, last_name, email, phone, license_number, license_state, license_expires, active) VALUES (?, ?, ?, ?, ?, ?, ?, ?)");
    $stmt->bind_param("ssssssss", $first_name, $last_name, $email, $phone, $license_number, $license_state, $license_expires, $active);
    $first_name = "Alice";
    $last_name = "Johnson";
    $email = "alice@example.com";
    $phone = "555-1234";
    $license_number = "D1234567";
    $license_state = "CA";
    $license_expires = "2025-12-31";
    $active = 1;
    $stmt->execute();
    $stmt->close();
    $conn->commit();

    // Render (very simple)
    echo "<h3>Vendors</h3><ul>";
    foreach ($vendors as $v) {
        echo "<li>{$v['vendor_id']} — {$v['name']}, {$v['type']}, {$v['phone']}</li>";
    }
    echo "</ul>";

    echo "<h3>Fuel Purchases</h3><ul>";
    foreach ($purchases as $p) {
        echo "<li>{$p['total_amount']} — {$p['fuel_grade']}, {$p['purchase_datetime']}</li>";
    }
    echo "</ul>";

} catch (mysqli_sql_exception $e) {
    // If a failure occurred during a transaction, attempt rollback
    if (isset($conn) && $conn->errno) {
        try { $conn->rollback(); } catch (Throwable $t) { /* ignore */ }
    }
    echo "A database error occurred.";
} finally {
    if (isset($result) && $result instanceof mysqli_result) { $result->free(); }
    if (isset($res) && $res instanceof mysqli_result) { $res->free(); }
    if (isset($stmt) && $stmt instanceof mysqli_stmt) { $stmt->close(); }
    if (isset($conn) && $conn instanceof mysqli) { $conn->close(); }
}
```

---

## 10) Common gotchas (call these out)

* **Forgetting `utf8mb4`** → garbled Unicode/emoji.
* **Using string interpolation for user input** → SQL injection risk; always `prepare + bind`.
* **Assuming `get_result()` exists** → it needs **mysqlnd**; otherwise use `bind_result()`/`fetch()`.
* **Not freeing results** in loops → creeping memory usage.
* **Swallowing errors** → turn on exceptions during development to spot issues immediately.
