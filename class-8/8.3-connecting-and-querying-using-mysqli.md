---
layout: default
title: 8.3 Connecting & Querying with MySQLi (OOP style)
nav_order: 3
---

# 8.3 Connecting & Querying with **MySQLi (OOP style)**

## 1) Goal for today

* Establish a **safe, reliable connection** to MySQL using MySQLi OOP.
* Run **simple queries** and **prepared statements**.
* Handle **errors and exceptions** correctly.
* Use different **fetch options**.
* Properly **free results** and **close** things.

> Why this matters: It directly supports our outcomes around secure data access, preventing SQL injection, and writing maintainable, object-oriented PHP.

---

## 2) Recommended defaults

* Use **OOP** style: `$conn = new mysqli(...)`.
* Immediately enable **exceptions** for MySQLi: `mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);`
* Set **UTF-8** correctly: `$conn->set_charset('utf8mb4');`
* Prefer **prepared statements** for any user input.

---

## 3) Minimal connection (with robust error handling)

```php
<?php
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT); // throw exceptions on errors

$host = '127.0.0.1';
$user = 'dbuser';
$pass = 'dbpass';
$db   = 'mydb';

try {
    $conn = new mysqli($host, $user, $pass, $db);
    $conn->set_charset('utf8mb4'); // full Unicode support
    // Optional: $conn->options(MYSQLI_OPT_INT_AND_FLOAT_NATIVE, 1);
    echo "Connected.\n";
} catch (mysqli_sql_exception $e) {
    // Never echo sensitive creds; log details server-side if needed
    die("Database connection failed.");
}
```

**Notes**

* With `mysqli_report(...STRICT)`, **connection/query errors throw exceptions**; catch them once instead of sprinkling `if (!$conn)` everywhere.
* If you *don’t* enable exceptions, you must check `$conn->connect_error`, `$conn->errno`, `$conn->error` manually after each call—more boilerplate, easier to miss.
* [MYSQLI_OPT_INT_AND_FLOAT_NATIVE](https://www.php.net/manual/en/mysqli.constants.php#constant.mysqli-opt-int-and-float-native) makes numeric columns return as PHP `int`/`float` instead of `string` (optional, but often useful).

---

## 4) Simple (non-prepared) queries — reads & writes

```php
// READ (no user input involved)
$sql = "SELECT id, first_name, last_name FROM students ORDER BY last_name";
$result = $conn->query($sql);         // mysqli_result
$rows   = $result->fetch_all(MYSQLI_ASSOC);  // requires mysqlnd
$result->free();                       // free memory when done

// WRITE (INSERT/UPDATE/DELETE)
$ins = "INSERT INTO students (first_name, last_name) VALUES ('Ava','Nguyen')";
$conn->query($ins);
echo "Inserted ID: " . $conn->insert_id . PHP_EOL;
echo "Affected rows: " . $conn->affected_rows . PHP_EOL;
```

**When are simple queries OK?**

* Fine for **static** SQL (no user input).
* The moment user input is involved → **prepared statements**.

---

### **What is mysqlnd (MySQL Native Driver)?**

**mysqlnd** stands for **MySQL Native Driver** — it’s the PHP-native client library that lets extensions like **MySQLi** and **PDO_MySQL** communicate directly with MySQL.

Before mysqlnd existed, PHP relied on **libmysqlclient**, an external C library provided by MySQL itself. Starting with PHP 5.4, mysqlnd became the **default and recommended** driver.

#### **Key differences**

| Feature             | **mysqlnd** (modern, default)                                                                                     | **libmysqlclient** (legacy alternative) |
| ------------------- | ----------------------------------------------------------------------------------------------------------------- | --------------------------------------- |
| **Origin**          | Built into PHP itself                                                                                             | Separate external library from MySQL    |
| **Compatibility**   | Designed for MySQLi, PDO_MySQL, and old mysql_*                                                                   | Used by older MySQL extensions          |
| **Memory use**      | Uses PHP’s own memory manager — lighter footprint                                                                 | Separate allocator; less efficient      |
| **Feature support** | Enables `get_result()`, `fetch_all()`, asynchronous queries, `fetch_object()` improvements, and native statistics | Lacks those PHP-specific features       |
| **Installation**    | Included automatically in modern PHP builds                                                                       | Must be compiled manually (obsolete)    |
| **Recommended?**    | ✅ Yes — default since PHP 5.4                                                                                     | ❌ Deprecated / not needed anymore       |

#### **In practical terms**

* If you can call `$stmt->get_result()` or `$result->fetch_all()` in MySQLi, you already have **mysqlnd**.
* Without it, you must use `bind_result()` + `fetch()` loops to retrieve data from prepared statements.
* You almost never need to install anything — every current PHP build includes mysqlnd by default.

---

## 5) Prepared statements (secure & fast)

### Parameter types for `bind_param()`

* `i` → integer
* `d` → double (float)
* `s` → string
* `b` → blob (binary)

### Example (safe SELECT)

```php
// Task: get users by status + min_id, both supplied by user
$status = $_GET['status'] ?? 'active';
$minId  = (int)($_GET['min'] ?? 1);

$stmt = $conn->prepare(
    "SELECT id, username, email
     FROM users
     WHERE status = ? AND id >= ?
     ORDER BY id"
);
$stmt->bind_param("si", $status, $minId); // s = string, i = integer
$stmt->execute();

// Option A: get_result() (requires mysqlnd)
$result = $stmt->get_result();
while ($row = $result->fetch_assoc()) {
    echo "{$row['id']}: {$row['username']} <{$row['email']}><br>";
}
$result->free();
$stmt->close();
```

### Alternative fetch (no mysqlnd): `bind_result() + fetch()`

```php
$stmt = $conn->prepare("SELECT id, username FROM users WHERE status = ?");
$stmt->bind_param("s", $status);
$stmt->execute();
$stmt->bind_result($id, $username);
while ($stmt->fetch()) {
    echo "$id: $username<br>";
}
$stmt->close();
```

### Prepared INSERT/UPDATE with transaction (and rollback on failure)

```php
try {
    $conn->begin_transaction(); // start

    $stmt = $conn->prepare(
        "INSERT INTO users (username, email, status) VALUES (?, ?, ?)"
    );
    $username = "maria";
    $email    = "maria@example.com";
    $status   = "active";
    $stmt->bind_param("sss", $username, $email, $status);
    $stmt->execute();
    $stmt->close();

    // maybe more statements here ...

    $conn->commit(); // all good
} catch (mysqli_sql_exception $e) {
    $conn->rollback(); // revert all changes
    // In production, log $e->getCode(), $e->getMessage()
    echo "Transaction failed; changes rolled back.";
}
```

---

## 6) Fetch options (reads)

Assume `$result = $conn->query("SELECT id, first_name, last_name FROM students");`

* **Associative row**

  ```php
  while ($row = $result->fetch_assoc()) { /* $row['first_name'] */ }
  ```
* **Numeric row**

  ```php
  while ($row = $result->fetch_row()) { /* $row[0] */ }
  ```
* **Both**

  ```php
  while ($row = $result->fetch_array(MYSQLI_BOTH)) { /* $row['id'] or $row[0] */ }
  ```
* **All at once** (mysqlnd)

  ```php
  $rows = $result->fetch_all(MYSQLI_ASSOC);
  ```
* **Iterate directly**

  ```php
  foreach ($result as $row) { /* associative by default when mysqlnd is present */ }
  ```

**Other handy properties/methods**

* `$result->num_rows` — number of rows in the result set
* `$result->data_seek($n)` — jump the internal pointer to row `n`
* `$conn->insert_id` — last AUTO_INCREMENT value
* `$conn->affected_rows` — rows changed by the last write

---

## 7) Error handling patterns (three levels)

**A. Best (exceptions enabled once)**

```php
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);
try {
    $conn = new mysqli($host, $user, $pass, $db);
    $conn->set_charset('utf8mb4');
    $conn->query("BAD SQL"); // will throw mysqli_sql_exception
} catch (mysqli_sql_exception $e) {
    echo "DB Error: " . $e->getMessage();
}
```

**B. Manual checks (exceptions OFF)**
Use **only** if you can’t enable exceptions:

```php
$conn = new mysqli($host, $user, $pass, $db);
if ($conn->connect_errno) { die("Connect error: " . $conn->connect_error); }

$result = $conn->query($sql);
if ($result === false) {
    echo "Query error [{$conn->errno}]: {$conn->error}";
}
```

**C. Statement-level errors**

```php
$stmt = $conn->prepare("SELECT * FROM users WHERE id = ?");
if (!$stmt) {
    echo "Prepare failed [{$conn->errno}]: {$conn->error}";
}
```

> Tip: In real apps, **log** `$e->getCode()` and `$e->getMessage()`; show students safe, generic messages.

---

## 8) Freeing results & closing resources

* **Result sets:** `$result->free();`
* **Statements:** `$stmt->close();`
* **Connections:** `$conn->close();`
* Large arrays: `unset($rows);` to free memory sooner in long-lived scripts.

> Order isn’t ultra-strict, but free what you’re done with. PHP’s GC will clean up at the end of request, yet explicit frees help memory in loops/long scripts.

---

## 9) Putting it all together (copy-paste demo)

```php
<?php
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);

$host = '127.0.0.1';
$user = 'dbuser';
$pass = 'dbpass';
$db   = 'mydb';

try {
    $conn = new mysqli($host, $user, $pass, $db);
    $conn->set_charset('utf8mb4');

    // Simple read (no user input)
    $result = $conn->query("SELECT id, first_name, last_name FROM students ORDER BY last_name");
    $students = $result->fetch_all(MYSQLI_ASSOC);
    $result->free();

    // Prepared read (user input)
    $status = 'active';
    $stmt = $conn->prepare("SELECT id, username, email FROM users WHERE status = ?");
    $stmt->bind_param("s", $status);
    $stmt->execute();
    $res = $stmt->get_result();
    $users = $res->fetch_all(MYSQLI_ASSOC);
    $res->free();
    $stmt->close();

    // Transactional write
    $conn->begin_transaction();
    $stmt = $conn->prepare("INSERT INTO logs (message) VALUES (?)");
    $msg  = "Viewed students & users";
    $stmt->bind_param("s", $msg);
    $stmt->execute();
    $stmt->close();
    $conn->commit();

    // Render (very simple)
    echo "<h3>Students</h3><ul>";
    foreach ($students as $s) {
        echo "<li>{$s['id']} — {$s['last_name']}, {$s['first_name']}</li>";
    }
    echo "</ul>";

    echo "<h3>Active Users</h3><ul>";
    foreach ($users as $u) {
        echo "<li>{$u['id']} — {$u['username']} &lt;{$u['email']}&gt;</li>";
    }
    echo "</ul>";

} catch (mysqli_sql_exception $e) {
    // If a failure occurred during a transaction, attempt rollback
    if (isset($conn) && $conn->errno) {
        try { $conn->rollback(); } catch (Throwable $t) { /* ignore */ }
    }
    echo "A database error occurred.";
} finally {
    if (isset($result) && $result instanceof mysqli_result) { $result->free(); }
    if (isset($res) && $res instanceof mysqli_result) { $res->free(); }
    if (isset($stmt) && $stmt instanceof mysqli_stmt) { $stmt->close(); }
    if (isset($conn) && $conn instanceof mysqli) { $conn->close(); }
}
```

---

## 10) Common gotchas (call these out)

* **Forgetting `utf8mb4`** → garbled Unicode/emoji.
* **Using string interpolation for user input** → SQL injection risk; always `prepare + bind`.
* **Assuming `get_result()` exists** → it needs **mysqlnd**; otherwise use `bind_result()`/`fetch()`.
* **Not freeing results** in loops → creeping memory usage.
* **Swallowing errors** → turn on exceptions during development to spot issues immediately.

---

## 11) Quick practice (5–10 min)

* Convert a vulnerable query:

```php
// from:
$email = $_GET['email'];
$sql = "SELECT id FROM users WHERE email = '$email'";
$rows = $conn->query($sql)->fetch_all(MYSQLI_ASSOC);

// to: (prepared)
$stmt = $conn->prepare("SELECT id FROM users WHERE email = ?");
$stmt->bind_param("s", $email);
$stmt->execute();
$rows = $stmt->get_result()->fetch_all(MYSQLI_ASSOC);
$stmt->close();
```

* Add a transaction that inserts two rows; force an error on the second and ensure rollback.
