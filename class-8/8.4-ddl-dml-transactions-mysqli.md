---
layout: default
title: 8.4 DDL & DML with **MySQLi (OOP)** + Transactions
nav_order: 4
---

# 8.4 DDL & DML with **MySQLi (OOP)** + Transactions

## 1) Today’s goals (35–50 min)

* Create and alter tables (DDL - data definition language) from PHP.
* Perform secure INSERT/UPDATE/DELETE (DML - data manipulation language) with prepared statements.
* Use transactions correctly: `begin_transaction()`, `commit()`, `rollback()`, and **savepoints**.
* Understand **ACID**, **isolation levels**, and how to handle **deadlocks** safely.

---

## 2) Setup (recommended boilerplate)

```php
<?php
// db.php — include in all examples below
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);

$host = 'db';
$user = 'mariadb';
$pass = 'mariadb';
$db   = 'mydb';

$conn = new mysqli($host, $user, $pass, $db);
$conn->set_charset('utf8mb4');
```

---

## 3) DDL from PHP: **CREATE TABLE** and **ALTER TABLE**

> Note: In MySQL, most **DDL autocommits** — you usually **can’t roll back** a CREATE/ALTER/DROP. Treat schema changes as separate, deliberate operations.

### 3.1 Create a table (InnoDB + constraints)

```php
$sql = <<<SQL
CREATE TABLE IF NOT EXISTS accounts (
  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  owner_name VARCHAR(80) NOT NULL,
  balance DECIMAL(12,2) NOT NULL DEFAULT 0.00,
  status ENUM('active','suspended','closed') NOT NULL DEFAULT 'active',
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT chk_balance_nonneg CHECK (balance >= 0)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
SQL;

$conn->query($sql);
echo "Table accounts ensured.\n";
```

### 3.2 Alter a table (add a column, add an index)

```php
// Add an index
$conn->query("ALTER TABLE accounts ADD INDEX idx_status (status)");

// Add a nullable notes column
$conn->query("ALTER TABLE accounts ADD COLUMN notes VARCHAR(255) NULL AFTER owner_name");
```

**Teaching notes**

* Use **InnoDB** for transactions and foreign keys.
* **DDL ≠ transactional**: implicit commits occur before/after most DDL.
* Add **indexes** to speed up lookups used in WHERE/JOIN/ORDER BY.

---

## 4) DML securely: **INSERT / UPDATE / DELETE** with prepared statements

### 4.1 INSERT (single row)

```php
$stmt = $conn->prepare(
  "INSERT INTO accounts (owner_name, balance, status) VALUES (?, ?, ?)"
);
$owner  = "Casey Kim";
$bal    = 100.00;  // decimal fits 'd' (double) binding
$status = "active";
$stmt->bind_param("sds", $owner, $bal, $status); // s=string, d=double, s=string
$stmt->execute();

$newId = $conn->insert_id;
$stmt->close();
echo "Created account id {$newId}\n";
```

### 4.2 INSERT (multiple rows efficiently)

```php
$data = [
  ['Ava Nguyen', 250.00, 'active'],
  ['Joel Reed',   50.00, 'active'],
  ['Mina Lopez',   0.00, 'suspended'],
];

$stmt = $conn->prepare("INSERT INTO accounts (owner_name, balance, status) VALUES (?, ?, ?)");
foreach ($data as [$owner, $bal, $status]) {
  $stmt->bind_param("sds", $owner, $bal, $status);
  $stmt->execute();
}
$stmt->close();
```

### 4.3 UPDATE with a WHERE clause (check affected rows)

```php
$stmt = $conn->prepare("UPDATE accounts SET status = ? WHERE id = ?");
$newStatus = "suspended";
$acctId    = 3;
$stmt->bind_param("si", $newStatus, $acctId);
$stmt->execute();

echo "Rows changed: {$conn->affected_rows}\n"; // 0 means no match or no change
$stmt->close();
```

### 4.4 DELETE (or “soft delete” suggestion)

```php
// Hard delete
$stmt = $conn->prepare("DELETE FROM accounts WHERE id = ?");
$stmt->bind_param("i", $acctId);
$stmt->execute();
$stmt->close();

// Soft delete alternative (preferred for auditability)
// UPDATE accounts SET status='closed' WHERE id=?;
```

**Best practices**

* Always **prepare + bind** when any user input is involved.
* Check **affected_rows** to confirm updates/deletes actually did something.
* Consider **soft deletes** to preserve history; enforce with **constraints** if needed.

---

## 5) Transactions — **ACID** in practice

### 5.1 Why transactions?

* **Atomicity**: group multiple statements into all-or-nothing units.
* **Consistency**: move the DB from one valid state to another.
* **Isolation**: keep concurrent transactions from interfering improperly.
* **Durability**: once committed, changes survive crashes.

### 5.2 Autocommit & starting a transaction

* MySQL autocommits every statement by default.
* With MySQLi OOP, use:

  * `$conn->begin_transaction();`
  * `$conn->commit();`
  * `$conn->rollback();`

### 5.3 Example: **Transfer funds** (classic multi-step write)

> Goal: move $amount from A to B; fail if insufficient funds; keep balance non-negative.

```php
function transfer(mysqli $conn, int $fromId, int $toId, float $amount): bool {
  if ($amount <= 0) { return false; }

  try {
    $conn->begin_transaction();

    // Lock rows to prevent race conditions (requires InnoDB)
    $sel = $conn->prepare("SELECT id, balance FROM accounts WHERE id IN (?, ?) FOR UPDATE");
    $sel->bind_param("ii", $fromId, $toId);
    $sel->execute();
    $res = $sel->get_result();

    $rows = [];
    while ($row = $res->fetch_assoc()) { $rows[$row['id']] = $row; }
    $res->free(); $sel->close();

    if (!isset($rows[$fromId]) || !isset($rows[$toId])) {
      throw new Exception("Account not found");
    }

    if ($rows[$fromId]['balance'] < $amount) {
      throw new Exception("Insufficient funds");
    }

    // Debit from A
    $upd = $conn->prepare("UPDATE accounts SET balance = balance - ? WHERE id = ?");
    $upd->bind_param("di", $amount, $fromId);
    $upd->execute(); $upd->close();

    // Credit to B
    $upd = $conn->prepare("UPDATE accounts SET balance = balance + ? WHERE id = ?");
    $upd->bind_param("di", $amount, $toId);
    $upd->execute(); $upd->close();

    $conn->commit();
    return true;

  } catch (mysqli_sql_exception $e) {
    $conn->rollback();
    return false;
  } catch (Exception $e) {
    $conn->rollback();
    return false;
  }
}
```

**Why `FOR UPDATE`?**

* It **locks** the selected rows so two transfers can’t read the same balance and both spend it.

### 5.4 **Savepoints** for partial rollbacks

```php
$conn->begin_transaction();
try {
  // Step 1
  // ...

  $conn->savepoint('after_step1');

  // Step 2
  // ...

  // Problem? Roll back to the savepoint, not the whole transaction:
  // $conn->query("ROLLBACK TO SAVEPOINT sp1");

  // No longer need a savepoint? Release it:
  // $conn->release_savepoint("sp1");

  $conn->commit();
} catch (Throwable $e) {
  $conn->rollback();
}
```

> You can also use SQL directly:

```php
$conn->query("SAVEPOINT sp1");
$conn->query("ROLLBACK TO SAVEPOINT sp1");
$conn->query("RELEASE SAVEPOINT sp1");
```

### 5.5 Isolation levels (practical overview)

* **READ COMMITTED**: avoids dirty reads; commonly used.
* **REPEATABLE READ** (MySQL default): consistent reads within a transaction; prevents non-repeatable reads; MySQL uses gap locks to reduce phantom issues.
* **SERIALIZABLE**: strongest isolation; most locking; lowest concurrency.

Set per session:

```php
$conn->query("SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED");
// then
$conn->begin_transaction();
```

### 5.6 Deadlocks & safe retry pattern

Even correct code can deadlock under concurrency. Handle it by retrying a few times.

```php
function runWithRetry(mysqli $conn, callable $fn, int $maxTries = 3): bool {
  for ($i = 1; $i <= $maxTries; $i++) {
    try {
      $conn->begin_transaction();
      $fn($conn);          // do all your queries here
      $conn->commit();
      return true;
    } catch (mysqli_sql_exception $e) {
      // ER_LOCK_DEADLOCK = 1213, ER_LOCK_WAIT_TIMEOUT = 1205
      if (in_array($conn->errno, [1213, 1205]) && $i < $maxTries) {
        $conn->rollback();
        usleep(100000 * $i); // backoff
        continue;
      }
      $conn->rollback();
      return false;
    }
  }
  return false;
}
```

Use:

```php
runWithRetry($conn, function(mysqli $conn) use ($fromId, $toId, $amount) {
  // execute the transfer steps here (no separate begin/commit inside)
});
```

**Transaction checklist**

* Use **InnoDB**.
* Group interdependent writes into **one** transaction.
* Use `SELECT ... FOR UPDATE` (or `LOCK IN SHARE MODE`) as appropriate.
* Choose an **isolation level** that matches requirements.
* **Retry** on deadlock/timeout; keep transactions **short**.

---

## 6) DDL + foreign keys (bonus: enforcing integrity)

```php
// Parent table
$conn->query("
  CREATE TABLE IF NOT EXISTS customers (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(80) NOT NULL
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
");

// Child with FK
$conn->query("
  CREATE TABLE IF NOT EXISTS orders (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    customer_id INT UNSIGNED NOT NULL,
    total DECIMAL(10,2) NOT NULL DEFAULT 0.00,
    CONSTRAINT fk_orders_customer FOREIGN KEY (customer_id)
      REFERENCES customers(id)
      ON DELETE RESTRICT ON UPDATE CASCADE
  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
");
```

> Teach when to use **CASCADE** vs **RESTRICT** vs **SET NULL**, and that FKs + transactions prevent many data-integrity bugs.

---

## 7) Using the `mysqli::$info` Property

The **`$mysqli->info`** property provides a short, human-readable summary about the **most recent query** executed on that connection.
It’s mainly useful for **INSERT**, **UPDATE**, **DELETE**, or **LOAD DATA** operations, giving details such as how many rows were affected or matched.

### **Common information returned**

Depending on the statement type, `info` may include:

* Number of rows affected (`Rows matched`, `Changed`, `Deleted`, `Inserted`)
* Number of warnings
* Duplicate key information (if applicable)

---

### **Example 1 — UPDATE with $mysqli->info**

```php
<?php
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);

$conn = new mysqli('localhost', 'dbuser', 'dbpass', 'mydb');
$conn->set_charset('utf8mb4');

$sql = "UPDATE accounts SET status = 'active' WHERE status = 'suspended'";
$conn->query($sql);

echo "Affected rows: " . $conn->affected_rows . "<br>";
echo "Info: " . $conn->info . "<br>";

$conn->close();
```

**Example output:**

```
Affected rows: 3
Info: Rows matched: 3  Changed: 3  Warnings: 0
```

---

### **Example 2 — INSERT with duplicates**

```php
$conn->query("
  INSERT INTO users (id, username, email)
  VALUES (1, 'maria', 'maria@example.com')
  ON DUPLICATE KEY UPDATE email = VALUES(email)
");

echo $conn->info;
```

**Possible output:**

```
Records: 1  Duplicates: 1  Warnings: 0
```

---

### **Example 3 — DELETE**

```php
$conn->query("DELETE FROM logs WHERE created_at < NOW() - INTERVAL 30 DAY");
echo $conn->info;
```

**Example output:**

```
Records: 12  Deleted: 12  Warnings: 0
```

---

### **Key points for teaching**

* `$conn->info` is a **string**, not a structured object — you can `echo` or `log` it directly.
* It reports on the **most recent statement** executed through that connection.
* It’s **connection-specific** — if multiple queries run on different `$mysqli` instances, check each separately.
* It’s especially handy for **logging**, **debugging**, or **summarizing database activity** after bulk operations.

---

### **Quick classroom prompt**

> “After performing an UPDATE or DELETE, try printing `$conn->info`. What does it tell you about how MySQL processed your statement? How does it differ from `$conn->affected_rows`?”

---

## 8) Full demo (copy/paste)

```php
<?php
require __DIR__ . '/db.php';

try {
  // Ensure schema
  $conn->query("DROP TABLE IF EXISTS accounts");
  $conn->query("
    CREATE TABLE accounts (
      id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
      owner_name VARCHAR(80) NOT NULL,
      balance DECIMAL(12,2) NOT NULL DEFAULT 0.00,
      status ENUM('active','suspended','closed') NOT NULL DEFAULT 'active',
      created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
      CHECK (balance >= 0)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  ");

  // Seed rows
  $stmt = $conn->prepare("INSERT INTO accounts (owner_name, balance, status) VALUES (?, ?, ?)");
  $rows = [
    ['Alice', 300.00, 'active'],
    ['Bob',   120.00, 'active'],
  ];
  foreach ($rows as [$n,$b,$s]) { $stmt->bind_param("sds", $n, $b, $s); $stmt->execute(); }
  $stmt->close();

  // Transaction: transfer 50 from Alice(id=1) to Bob(id=2)
  $amount = 50.00;
  $conn->begin_transaction();

  $sel = $conn->prepare("SELECT id, balance FROM accounts WHERE id IN (1,2) FOR UPDATE");
  $sel->execute();
  $res = $sel->get_result();
  $a = $res->fetch_all(MYSQLI_ASSOC); $res->free(); $sel->close();

  // Map by id
  $map = [];
  foreach ($a as $r) { $map[$r['id']] = (float)$r['balance']; }
  if ($map[1] < $amount) { throw new Exception("Insufficient funds"); }

  $u = $conn->prepare("UPDATE accounts SET balance = balance - ? WHERE id = 1");
  $u->bind_param("d", $amount); $u->execute(); $u->close();

  $u = $conn->prepare("UPDATE accounts SET balance = balance + ? WHERE id = 2");
  $u->bind_param("d", $amount); $u->execute(); $u->close();

  $conn->commit();

  // Show results
  $result = $conn->query("SELECT id, owner_name, balance FROM accounts ORDER BY id");
  echo "<pre>" . htmlspecialchars(print_r($result->fetch_all(MYSQLI_ASSOC), true)) . "</pre>";
  $result->free();

} catch (Throwable $e) {
  // Roll back on any error
  if ($conn->errno) { try { $conn->rollback(); } catch (Throwable $t) {} }
  echo "A database error occurred.";
} finally {
  $conn->close();
}
```

---

## 9) Key takeaways

* DDL (CREATE/ALTER) usually **autocommits** — plan schema changes carefully.
* For DML with user input, always use **prepared statements**.
* **Transactions** protect multi-step changes; keep them short, lock rows deliberately, pick the right isolation level, and **retry** on deadlocks.
* Prefer **InnoDB**, `utf8mb4`, and exception-based error handling in MySQLi OOP.
