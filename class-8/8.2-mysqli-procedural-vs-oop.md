---
layout: default
title: 8.2 MySQLi Procedural vs Object-Oriented Styles
nav_order: 2
---

# 8.2 MySQLi Procedural vs Object-Oriented Styles

## 1) Opening — Why this matters

In the last video, we learned that the old `mysql_*` extension was replaced by **MySQLi**, which stands for *MySQL Improved*. Today, we’ll look at the two styles you can use with MySQLi: **procedural** and **object-oriented (OOP)**. Understanding both styles is important because you’ll see both in examples online, but we’ll focus on OOP moving forward since it better aligns with modern PHP practices and prepares us for using PDO next week.

---

## 2) MySQLi can be used in two styles

Unlike the old `mysql_*` functions, **MySQLi** provides both:

| Style                     | Description                                         | Syntax style                                 | Best suited for                                |
| ------------------------- | --------------------------------------------------- | -------------------------------------------- | ---------------------------------------------- |
| **Procedural**            | Function-based, similar to old `mysql_*` extension. | `mysqli_connect()`, `mysqli_query()`, etc.   | Quick scripts, simple legacy updates.          |
| **Object-Oriented (OOP)** | Uses the `mysqli` class and its methods.            | `$conn = new mysqli(...)`, `$conn->query()`. | Modern, structured PHP code, reusable objects. |

Both styles use the same underlying driver and have the same functionality — but the syntax and how you handle connections, queries, and errors differ.

---

## 3) Basic connection example

### Procedural style:

```php
<?php
// mysqli_procedural.php
$host = 'db';
$user = 'mariadb';
$pass = 'mariadb';
$db   = 'mydb';

// Connect to the database
$conn = mysqli_connect($host, $user, $pass, $db);

// Check for connection errors
if (!$conn) {
    die("Connection failed: " . mysqli_connect_error());
}

echo "Connected successfully!";

// Close the connection
mysqli_close($conn);
?>
```

### Object-oriented style:

```php
<?php
// mysqli_oop.php
$host = 'db';
$user = 'mariadb';
$pass = 'mariadb';
$db   = 'mydb';

// Create a new mysqli object
$conn = new mysqli($host, $user, $pass, $db);

// Check for connection errors
if ($conn->connect_error) {
    die("Connection failed: " . $conn->connect_error);
}

echo "Connected successfully!";

// Close the connection
$conn->close();
?>
```

**Discussion point:**
Both accomplish the same thing — but in OOP, `$conn` is an instance of the `mysqli` class, which means it has **methods** and **properties**, not just functions.

---

## 4) Running queries — Procedural vs OOP

### Procedural:

```php
$query = "SELECT service_date,total_cost FROM maintenance_records";
$result = mysqli_query($conn, $query);

if ($result) {
    while ($row = mysqli_fetch_assoc($result)) {
        echo $row['service_date'] . " " . $row['total_cost'] . "<br>";
    }
    mysqli_free_result($result);
} else {
    echo "Error: " . mysqli_error($conn);
}
```

### OOP:

```php
$query = "SELECT service_date,total_cost FROM maintenance_records";
$result = $conn->query($query);

if ($result) {
    while ($row = $result->fetch_assoc()) {
        echo $row['service_date'] . " " . $row['total_cost'] . "<br>";
    }
    $result->free();
} else {
    echo "Error: " . $conn->error;
}
```

**Key difference:**

* Procedural → uses `mysqli_query()` and standalone functions like `mysqli_fetch_assoc()`.
* OOP → calls methods like `$conn->query()` and `$result->fetch_assoc()`.
* The OOP version feels more “natural” in modern PHP, especially when working with multiple connections or classes.

---

## 5) Prepared statements — the secure way to query

### Procedural:

```php
$sql = "SELECT service_date,total_cost FROM maintenance_records WHERE vehicle_id = ?";
$stmt = mysqli_prepare($conn, $sql); 
// Bind the variable to the parameter, where "i" indicates integer type
mysqli_stmt_bind_param($stmt, "i", $vehicle_id); 
$vehicle_id = 1; // Example vehicle ID
// Execute the prepared statement, no need to pass params here
// - the most recent bound values are used
mysqli_stmt_execute($stmt); 
$result = mysqli_stmt_get_result($stmt);
$row = mysqli_fetch_assoc($result);
echo $row['service_date'] . " " . $row['total_cost'];
mysqli_stmt_close($stmt);
```

### OOP:

```php
$stmt = $conn->prepare("SELECT service_date,total_cost FROM maintenance_records 
    WHERE vehicle_id = ?");
// Bind the variable to the parameter, where "i" indicates integer type
$stmt->bind_param("i", $vehicle_id); 
$vehicle_id = 1; // Example vehicle ID
// Execute the prepared statement, no need to pass params here - the most recent bound values are used
$stmt->execute(); 
$result = $stmt->get_result();
$row = $result->fetch_assoc();
echo $row['service_date'] . " " . $row['total_cost'];
$stmt->close();
```

**Same logic, different syntax:**
The OOP version looks cleaner and leads directly into how PDO handles prepared statements (which we’ll cover next week).

---

## 6) Error handling differences

### Procedural:

```php
if (!$result) {
    echo "Query failed: " . mysqli_error($conn);
}
```

### OOP:

```php
if (!$result) {
    echo "Query failed: " . $conn->error;
}
```

Or you can make error handling more advanced by enabling **exceptions** (not possible in procedural style):

```php
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);
$conn = new mysqli($host, $user, $pass, $db);
$conn->set_charset('utf8mb4');
```

Now any query error will throw an **Exception**, which you can catch:

```php
try {
    $conn->query("BAD SQL");
} catch (mysqli_sql_exception $e) {
    echo "Caught error: " . $e->getMessage();
}
```

---

## 7) Advantages of the OOP style

* Cleaner syntax and better readability.
* Easier to manage multiple database connections (each as its own object).
* Easier integration into classes and larger applications.
* Supports exceptions and more robust error handling.
* Natural bridge into PDO (same concepts of objects, methods, exceptions).

---

## 8) Advantages of the procedural style

* Simpler for small, single-file scripts or quick testing.
* Easier for students who are more comfortable with function-based code.
* Helpful when updating old code that used `mysql_*` functions.

But procedural style doesn’t scale well in larger applications — and it can’t leverage object-oriented features like inheritance or encapsulation.

---

## 9) Closing summary

Both procedural and OOP MySQLi styles do the same thing under the hood — they connect to MySQL and let you send queries. But the **OOP approach** gives us cleaner, more maintainable, and more modern code. It fits perfectly with what we’ll do next week using **PDO**, which uses the same object-oriented principles but works across multiple databases.

---

## 10) Optional demo idea

You can show the **same page** loading results with both styles by wrapping them in tabs or sections in a single file. That visual comparison helps the difference “click” for students.
