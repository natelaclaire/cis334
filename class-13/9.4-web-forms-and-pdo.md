---
layout: default
title: 9.4 PDO for Server-Side Validation & Secure Form Handling
nav_order: 4
---

# 9.4 PDO for Server-Side Validation & Secure Form Handling

## 0) Why this matters

Form handling is where apps are most exposed. We must validate data on the **server** and store it safely. **PDO** strengthens this workflow with prepared statements, typed binding, consistent errors via exceptions, and easy transactions.

---

## 1) Threat model — what can go wrong

* **SQL injection** (unsafe string interpolation in queries)
* **CSRF** (forged submissions)
* **Weak validation** (missing required fields, wrong formats, overly long inputs)
* **Duplicate/constraint errors** (unique email/username)
* **Leaky errors** (exposing stack traces or SQL to users)

PDO doesn’t do validation for you, but it makes **safe DB writes** the default, and gives you reliable errors to handle.

---

## 2) Secure form architecture

Pattern we’ll use:

1. **Show form** with a **CSRF token** stored in `$_SESSION`.
2. **POST handler**: normalize + validate → if errors, redisplay with messages.
3. If valid: **prepared INSERT** via PDO, catch constraint errors (e.g., duplicate email).
4. **PRG pattern** (Post/Redirect/Get) to avoid resubmits.

---

## 3) The form (with CSRF + sticky values)

```php
<?php
// form.php
session_start();
if (empty($_SESSION['csrf'])) {
  $_SESSION['csrf'] = bin2hex(random_bytes(32));
}
$old = $_SESSION['old'] ?? [];
$errors = $_SESSION['errors'] ?? [];
unset($_SESSION['old'], $_SESSION['errors']);
?>
<!doctype html><meta charset="utf-8">
<h1>Register</h1>
<form method="post" action="handle_register.php" novalidate>
  <input type="hidden" name="csrf" value="<?= htmlspecialchars($_SESSION['csrf']) ?>">
  <label>Username
    <input name="username" value="<?= htmlspecialchars($old['username'] ?? '') ?>" required>
    <small style="color:red"><?= $errors['username'] ?? '' ?></small>
  </label><br>
  <label>Email
    <input name="email" type="email" value="<?= htmlspecialchars($old['email'] ?? '') ?>" required>
    <small style="color:red"><?= $errors['email'] ?? '' ?></small>
  </label><br>
  <label>Password
    <input name="password" type="password" required>
    <small style="color:red"><?= $errors['password'] ?? '' ?></small>
  </label><br>
  <button>Create Account</button>
</form>
```

---

## 4) Validation, normalization, and **PDO** insert (core demo, 3–4 min)

```php
<?php
// handle_register.php
session_start();

// 1) CSRF check
if (!hash_equals($_SESSION['csrf'] ?? '', $_POST['csrf'] ?? '')) {
  http_response_code(419);
  exit('Invalid CSRF token');
}

// 2) Collect + normalize
$username = trim((string)($_POST['username'] ?? ''));
$email    = strtolower(trim((string)($_POST['email'] ?? '')));
$password = (string)($_POST['password'] ?? '');

// 3) Validate (server-side)
$errors = [];

if ($username === '' || strlen($username) < 3 || strlen($username) > 32 || !preg_match('/^[A-Za-z0-9_]+$/', $username)) {
  $errors['username'] = '3–32 chars; letters, numbers, underscore only.';
}
if (!filter_var($email, FILTER_VALIDATE_EMAIL) || strlen($email) > 120) {
  $errors['email'] = 'Enter a valid email (max 120 chars).';
}
if (strlen($password) < 8) {
  $errors['password'] = 'Use at least 8 characters.';
}

if ($errors) {
  $_SESSION['old'] = ['username'=>$username, 'email'=>$email];
  $_SESSION['errors'] = $errors;
  header('Location: form.php');
  exit;
}

// 4) Hash password server-side (validation is separate from storage)
$hash = password_hash($password, PASSWORD_DEFAULT);

// 5) PDO connection (safe defaults)
$pdo = new PDO(
  "mysql:host=127.0.0.1;dbname=mydb;charset=utf8mb4",
  "dbuser",
  "dbpass",
  [
    PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    PDO::ATTR_EMULATE_PREPARES   => false,
  ]
);

// 6) Insert safely with prepared statement
try {
  $stmt = $pdo->prepare("
    INSERT INTO users (username, email, password_hash, status)
    VALUES (:u, :e, :p, 'active')
  ");
  $stmt->execute([
    ':u' => $username,
    ':e' => $email,
    ':p' => $hash,
  ]);
} catch (PDOException $e) {
  // 23000 => integrity constraint violation (e.g., duplicate email/username)
  if ($e->getCode() === '23000') {
    $_SESSION['old'] = ['username'=>$username, 'email'=>$email];
    // Decide which unique key failed by querying or by message matching (keep message generic to users)
    $_SESSION['errors'] = ['email' => 'That email or username is already taken.'];
    header('Location: form.php'); exit;
  }
  // Unknown DB error: log privately; show safe message
  error_log("DB error: ".$e->getMessage());
  http_response_code(500);
  exit('Unexpected error. Please try again later.');
}

// 7) PRG: success
header('Location: thankyou.php');
exit;
```

**What PDO improves here**

* **Prepared statements** separate SQL from data → blocks SQL injection.
* **No string concatenation** → no quoting/escaping mistakes.
* **Exceptions** make error handling consistent (`ERRMODE_EXCEPTION`).
* **SQLSTATE codes** (`23000`) let you handle constraint violations cleanly.
* **Typed binding** (e.g., `PDO::PARAM_INT` for LIMIT/OFFSET in other endpoints).

---

## 5) Whitelisting & safe dynamic SQL (60–90s)

> “If the form controls a **column name** or **sort order**, never inject raw strings. **Whitelist** allowed values.”

```php
// Example: safe sorting
$allowed = ['username','created_at'];
$sort = $_GET['sort'] ?? 'created_at';
if (!in_array($sort, $allowed, true)) { $sort = 'created_at'; }

$sql = "SELECT id, username, email FROM users ORDER BY $sort DESC"; // $sort is whitelisted
$rows = $pdo->query($sql)->fetchAll();
```

> “For **values** (strings, numbers, dates), always use `?` or `:named` placeholders; for **identifiers** (columns/tables), **whitelist only**.”

---

## 6) Validation patterns students should memorize (45–60s)

* **Required**: not empty after `trim()`.
* **Length**: enforce both client & server (e.g., 3–32).
* **Format**: `filter_var()` for email/URL; regex for usernames.
* **Normalization**: `strtolower` emails; Unicode normalization as needed.
* **Uniqueness**: rely on **UNIQUE** constraints; catch `23000`.
* **Passwords**: `password_hash()` + `password_verify()`; never store plain text.

---

## 7) Optional: Multi-step forms & transactions (45s)

> “For multi-table writes (e.g., create user + profile), wrap inserts in a **transaction** so either **all** rows are committed or none.”

```php
try {
  $pdo->beginTransaction();

  // Insert user…
  // Insert profile… (uses $pdo->lastInsertId())

  $pdo->commit();
} catch (Throwable $e) {
  if ($pdo->inTransaction()) { $pdo->rollBack(); }
  error_log($e->getMessage());
  exit('Could not save your data.');
}
```

---

## 8) Output escaping & PRG (30–45s)

* Escape dynamic output: `htmlspecialchars($value, ENT_QUOTES)` to prevent XSS when redisplaying old values or showing messages.
* Use **Post/Redirect/Get**: after successful POST, **redirect** to avoid duplicate submissions.

---

## 9) Quick SQLite swap (15–20s)

> “Everything above works the same with **SQLite** — just change the DSN and remove user/pass.”

```php
$pdo = new PDO("sqlite:" . __DIR__ . "/example.sqlite");
$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
```

---

## 10) Common pitfalls (30–45s)

* Concatenating user input into SQL → ❌
* Forgetting CSRF tokens on state-changing forms → ❌
* Relying on client-side validation only → ❌
* Exposing raw exception messages to users → ❌
* Not catching `23000` for UNIQUE violations → ❌

---

## 11) Mini-lab (5–10 min)

1. Add server-side checks for `min` and `max` length on username; demonstrate rejection.
2. Add a **UNIQUE email** constraint; attempt duplicate insert; catch and display a friendly message.
3. Implement PRG and show that refreshing the thank-you page does not re-submit.

---

### Closing line (10–15s)

> “PDO doesn’t replace validation — it **enforces safe database writes**. Combine **server-side validation**, **CSRF tokens**, **prepared statements**, and **clean error handling**, and you’ll have secure, reliable form processing in PHP.”
