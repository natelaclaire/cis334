# Object-Oriented PHP

### Slide 1 – Title

“Welcome, everyone.  Today we begin our exploration of object‑oriented programming in PHP 8.3.  In the first semester you learned foundational PHP skills—functions, control structures, arrays, files, user input.  This term we build on that foundation by designing applications with classes, objects and more structured design techniques.  By the end of this module you’ll know how to create and use classes, manage visibility, apply inheritance, work with interfaces and traits, and take advantage of new features introduced in PHP 8.3.  Let’s dive in!”

---

### Slide 2 – Agenda

“Here’s our roadmap.  We’ll start by discussing **why** object‑oriented programming (OOP) is useful.  Then we’ll cover the basic building blocks: classes and objects, properties and methods, and constructors and destructors.  We’ll look at encapsulation and visibility, then move on to inheritance and polymorphism.  We’ll compare interfaces and abstract classes, explore traits, and discuss static members, final keywords and the scope resolution operator.  After that we’ll demystify PHP’s magic methods.  We’ll finish with a look at what’s new in PHP 8.3 and end with some best‑practice tips and a summary.  Each section ties back to the course outcomes—designing dynamic web applications, writing clear PHP code and preparing you for database integration later in the term.”

---

### Slide 3 – Why OOP?

“Why bother with OOP?  First, classes allow us to **model real‑world entities** by encapsulating both data and behaviour.  Second, OOP promotes **reuse and maintainability**—instead of copying code, you can inherit behaviour or compose objects together.  Third, encapsulation enables us to **hide internal state** and expose a clean API, reducing coupling and making future changes safer.  Finally, OOP supports **extensibility**; polymorphism and interfaces let you add new features without breaking existing code.  These benefits are especially important in larger projects such as database‑driven web applications.”

---

### Slide 4 – Classes & Objects

“In PHP, you define a class with the `class` keyword.  A class may contain **constants**, **properties** and **methods**, and its name must start with a letter or underscore.  PHP class names are case‑insensitive.  Once a class is defined, you create an **object** (an instance) using the `new` keyword; if the constructor takes no arguments, parentheses are optional.  On this slide you see a simple `Person` class with a typed property `$name`, a constructor that sets the name and a `greet()` method returning a string.  The code illustrates how OOP keeps state (`$name`) and behaviour (`greet()`) together in one unit.”

---

### Slide 5 – Properties & Methods

“Classes define **properties** to hold state.  You can declare them public, protected or private; if you omit a visibility keyword, they default to `public`.  Properties can be typed, which improves reliability, and you should prefer explicit types whenever possible.  **Methods** define behaviour.  Most methods operate on an object instance and can access `$this`, while **static methods** belong to the class itself and cannot use `$this`.  Additionally, classes may declare **constants**.  These are immutable values accessed with the scope resolution operator (`ClassName::CONSTANT`).  PHP 8.3 extends constants by allowing you to declare their types—ensuring a constant such as `public const int ID = 1;` always holds an integer value.”

---

### Slide 6 – Constructors & Destructors

“When you create an object, PHP calls its **constructor**—a special method named `__construct()`.  Constructors often initialize properties or set up resources.  If your class extends a parent class and you need the parent constructor’s logic, you must call it explicitly via `parent::__construct()`.  Constructors can accept typed parameters with default values.  Complementing constructors are **destructors** (`__destruct()`).  They run when the last reference to an object is destroyed or at script termination.  Use destructors to close file handles, release database connections or perform other cleanup.  Parent destructors are not called automatically, so call `parent::__destruct()` if needed.  The examples illustrate both concepts: `Car` sets a default model in its constructor, and `FileHandler` closes an open file in its destructor.”

---

### Slide 7 – Encapsulation & Visibility

“One of the pillars of OOP is **encapsulation**.  It means hiding an object’s internal data and exposing a controlled interface.  In PHP you control access using **visibility modifiers**: `public` members are accessible from anywhere; `protected` members are accessible within the class and its subclasses; and `private` members are accessible only within the class that defines them.  If you don’t specify a visibility for a property, it is public by default.  Encapsulation allows you to change how data is stored without affecting code that relies on the public API.  The diagram on the slide shows a private `$data` property shielded from direct access and a public `getData()` method that exposes it safely.”

---

### Slide 8 – Inheritance & Polymorphism

“PHP supports **single inheritance**: a class may extend one parent class to reuse and specialize its behaviour.  Subclasses inherit all **public** and **protected** properties and methods.  Private members are not inherited, and visibility can be relaxed (e.g., changing a protected method to public) but cannot be restricted.  You can build multi‑level hierarchies (child of a child), but PHP does not support multiple inheritance.  **Polymorphism** means that objects of different classes can be treated uniformly if they share a common interface or base class.  You override a method in a child class to provide specialized behaviour, and at runtime PHP calls the appropriate version.  This allows functions to accept any object implementing a given interface and still behave correctly.”

---

### Slide 9 – Interfaces & Abstract Classes

“An **interface** defines a set of method signatures and constants but provides no implementation.  All interface methods are implicitly public, and any class that *implements* an interface must implement **all** of its methods with compatible parameter names.  Interfaces allow you to define a contract and write code against that contract rather than against concrete classes.  PHP also provides **abstract classes**.  An abstract class may contain both abstract methods (which must be implemented by child classes) and concrete methods.  You cannot instantiate an abstract class directly, but you can provide shared behaviour that is inherited by subclasses.  The table compares the two: both interfaces and abstract classes are not instantiable; interfaces only declare public methods and constants, while abstract classes can include concrete methods and properties; classes can implement multiple interfaces but can extend only one abstract class.”

---

### Slide 10 – Traits

“PHP’s **traits** solve the problem of code reuse in a single‑inheritance language.  A trait is like a partial class: you define methods and properties in a trait, then `use` it inside one or more classes.  Traits cannot be instantiated directly; they must be imported into classes.  When a class uses multiple traits or inherits from a parent, PHP resolves conflicts according to a precedence order: methods defined in the class override trait methods, and trait methods override inherited methods.  Use traits judiciously to share functionality such as logging or timestamping across unrelated classes without creating deep inheritance hierarchies.”

---

### Slide 11 – Static, Final & Scope

“A **static** property or method belongs to the class itself rather than any object.  You access static members with `ClassName::member`; inside the class you can also use `self::member`.  Static methods cannot use `$this` because they are not tied to a particular instance.  The **final** keyword prevents modification: a `final` class cannot be extended, and a `final` method cannot be overridden in subclasses.  Use `final` to lock down critical behaviour.  The **scope resolution operator** (`::`) is used to access class constants, static properties and static methods.  Within classes you can use `parent::` to call a parent’s static member or method and `static::` for late static binding.  Understanding these keywords helps you organize code effectively and avoid unintended overrides.”

---

### Slide 12 – Magic Methods

“PHP reserves method names beginning with a double underscore (`__`) for **magic methods**.  These special methods let you customize how objects behave in specific situations.  The constructor (`__construct`) and the cloning method (`__clone`) run when an object is created and cloned.  Magic methods like `__serialize` and `__unserialize` handle object serialization, while `__debugInfo` customizes debug output.  Property and method overloading methods (`__get`, `__set`, `__isset`, `__unset`, `__call`, `__callStatic`) allow you to intercept access to undefined or inaccessible members.  `__toString` lets an object be converted to a string, and `__invoke` makes an object callable like a function.  Except for the constructor, destructor and clone methods, magic methods must be declared **public**.  Use these methods sparingly and consistently to implement advanced behaviours such as proxies or dynamic properties.”

---

### Slide 13 – What’s New in PHP 8.3

“PHP 8.3 introduces several improvements relevant to OOP.  **Typed class constants** now allow you to declare the expected type of a class constant, adding another layer of type safety.  **Dynamic constant fetch** lets you access class constants dynamically using variable names (e.g., `C::${'A'}`).  The new `#[Override]` attribute enforces that a method indeed overrides a parent method; if it doesn’t, PHP will throw an error, helping you avoid subtle bugs.  Finally, **deep cloning of readonly properties** ensures that when you clone an object with a readonly property containing another object, the inner object is also cloned rather than shared.  These features enhance type safety and developer confidence when writing object‑oriented code.”

---

### Slide 14 – Best Practices & Tips

“To conclude, here are some best practices.  **Choose appropriate visibility** for your members: don’t make everything public.  **Prefer composition over inheritance** where possible; combine objects rather than build long inheritance chains.  Always **declare types and enable strict typing** for reliability, especially when interacting with MySQL later.  **Define interfaces** to decouple your code from specific implementations.  **Use traits carefully**; avoid name conflicts and don’t overuse them.  **Explicitly call parent constructors and destructors** when extending classes.  Finally, adopt the **PSR‑12 coding standards** and autoloading conventions to keep your codebase organized and professional.  Following these guidelines will help you meet the course outcomes: writing clean, maintainable, secure PHP scripts and preparing you for interacting with databases.”

---

### Slide 15 – Conclusion

“Let’s recap.  OOP organizes code around objects, improving maintainability and clarity.  Classes define state and behaviour; objects are specific instances.  Encapsulation with proper visibility protects internal state.  Inheritance, interfaces, traits and polymorphism enable code reuse and extensibility.  PHP 8.3 offers typed constants, dynamic constant fetch, override checks and deep cloning of readonly properties.  Keep exploring design patterns and best practices to master object‑oriented PHP.  In the next units we’ll connect these principles to MySQL, designing relational schemas, writing SQL queries and building dynamic, stateful web applications.  Thank you!”

---
