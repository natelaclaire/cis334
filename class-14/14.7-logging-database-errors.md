---
layout: default
title: 14.7 Logging Database Errors in a Production-Safe Way with PHP 8.3
nav_order: 7
---

# 14.7 Logging Database Errors in a Production-Safe Way with PHP 8.3

## 1. Opening

In earlier videos, we focused on:

* Types of PHP errors
* Error reporting and `display_errors`
* Practical debugging techniques
* Debugging database queries with PDO
* Debugging forms, sessions, and state

In this video, we’ll narrow in on one key skill for real-world applications:
**How to log database errors in a way that is safe for production.**

The goal is simple:

* **Developers** get detailed error information in a log.
* **Users** only see a generic, non-sensitive error message.

---

## 2. Why Production Logging Is Different from Development

In development, it’s fine to:

* Show full error messages on screen.
* Dump SQL queries and parameters.
* Print stack traces.

In production, that’s dangerous. Database error messages might reveal:

* Table and column names
* SQL queries
* File system paths
* Even raw user data

An attacker can use this information to probe your application.

**So the rule is:**

* In production: **log detailed errors** privately, show users **generic messages**.
* In development: you can show details, but don’t forget to turn them off later.

---

## 3. Base PHP Settings for Production Logging

At the configuration level, you want something like this:

```ini
display_errors = Off
log_errors = On
error_reporting = E_ALL
```

This tells PHP:

* Report all errors.
* Do not display them in the browser.
* Send them to the error log.

On many servers, you’ll set this in `php.ini` or a similar config, not in your PHP scripts.

---

## 4. Using PDO with Exceptions and Logging

Step one: make sure PDO is in **exception mode**.

### PDO setup for production logging

```php
<?php
declare(strict_types=1);

$dsn  = 'mysql:host=localhost;dbname=shop;charset=utf8mb4';
$user = 'shop_user';
$pass = 'secret';

try {
    $pdo = new PDO($dsn, $user, $pass, [
        PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    ]);
} catch (PDOException $e) {
    // Log the detailed error
    error_log("Database connection error: " . $e->getMessage());

    // Show a generic message to the user
    http_response_code(500);
    echo "We’re experiencing technical difficulties. Please try again later.";
    exit;
}
```

Here’s what’s happening:

* Detailed error information goes to the PHP error log.
* The user only sees a generic message.
* HTTP status is set to 500 (internal server error).

---

## 5. Logging Query Errors Safely

Next, wrap your queries in `try/catch` and log the exception details.

### Example: Insert query with safe logging

```php
$sql = "INSERT INTO orders (product, price, quantity, total)
        VALUES (:product, :price, :quantity, :total)";

$params = [
    ':product'  => $product,
    ':price'    => $price,
    ':quantity' => $quantity,
    ':total'    => $total,
];

try {
    $stmt = $pdo->prepare($sql);
    $stmt->execute($params);
} catch (PDOException $e) {
    // Log includes the SQL and parameters (this is for the log, not for users)
    $logMessage = "DB error in " . __FILE__ . " line " . __LINE__ . PHP_EOL
        . "Message: " . $e->getMessage() . PHP_EOL
        . "SQL: " . $sql . PHP_EOL
        . "Params: " . var_export($params, true) . PHP_EOL;

    error_log($logMessage);

    // Generic user-facing message
    http_response_code(500);
    echo "There was a problem saving your data. Please try again later.";
    exit;
}
```

Key points:

* Log message includes file, line, SQL, and parameter values.
* This is very helpful for debugging but kept out of the browser.
* User sees a simple, non-technical message.

---

## 6. Centralizing Logging in a Helper Function

Instead of repeating `error_log()` everywhere, create a small helper.

### Example: simple logging helper

```php
function logDbError(PDOException $e, string $sql, array $params = []): void
{
    $logMessage = "[DB ERROR] " . date('Y-m-d H:i:s') . PHP_EOL
        . "File: " . $e->getFile() . " (line " . $e->getLine() . ")" . PHP_EOL
        . "Message: " . $e->getMessage() . PHP_EOL
        . "SQL: " . $sql . PHP_EOL
        . "Params: " . var_export($params, true) . PHP_EOL
        . "Trace: " . $e->getTraceAsString() . PHP_EOL
        . str_repeat('-', 80) . PHP_EOL;

    error_log($logMessage);
}
```

Then use it:

```php
try {
    $stmt = $pdo->prepare($sql);
    $stmt->execute($params);
} catch (PDOException $e) {
    logDbError($e, $sql, $params);
    http_response_code(500);
    echo "We couldn’t complete your request. Please try again later.";
    exit;
}
```

Benefits:

* All DB errors are logged in a consistent format.
* Easier to search and filter logs.
* Easy to extend later (e.g., send to a file, a monitoring system, or email).

---

## 7. Choosing Where the Log Goes

By default, `error_log()` writes to the server’s default error log.

You can change this in `php.ini`:

```ini
log_errors = On
error_log = /var/log/php_errors.log
```

Or at runtime (often better in a config file):

```php
ini_set('log_errors', '1');
ini_set('error_log', __DIR__ . '/logs/app_errors.log');
```

**Production tip:**

* Use a dedicated log file per application if possible.
* Make sure file permissions are correct and logs are not web-accessible.
* Make sure log files are rotated (via system tools like logrotate).

---

## 8. Avoid Logging Sensitive Data

While logging parameters is useful, be careful with sensitive fields:

* Passwords
* Credit card numbers
* Social security numbers
* Any personally sensitive information

### Example: sanitize sensitive parameters before logging

```php
function sanitizeParams(array $params): array
{
    $sanitized = $params;

    foreach ($sanitized as $key => $value) {
        if (stripos($key, 'password') !== false) {
            $sanitized[$key] = '[REDACTED]';
        }
        // Add other rules as needed
    }

    return $sanitized;
}

function logDbError(PDOException $e, string $sql, array $params = []): void
{
    $params = sanitizeParams($params);

    $logMessage = "[DB ERROR] " . date('Y-m-d H:i:s') . PHP_EOL
        . "Message: " . $e->getMessage() . PHP_EOL
        . "SQL: " . $sql . PHP_EOL
        . "Params: " . var_export($params, true) . PHP_EOL
        . str_repeat('-', 80) . PHP_EOL;

    error_log($logMessage);
}
```

This lets you debug problems without storing sensitive data in logs.

---

## 9. User-Friendly Error Responses

From the user’s perspective, database errors should never show raw SQL or internal details.

Examples of acceptable user messages:

* “We’re having trouble processing your request. Please try again later.”
* “There was a problem saving your information. Our team has been notified.”

If you want to provide more context:

* Give the user a **generic error code** (e.g., `REF: 2025-12-05-1234`).
* Include that reference in the log as well so you can correlate.

Example:

```php
$errorRef = 'ERR-' . date('YmdHis');

logDbError($e, $sql, $params + ['error_ref' => $errorRef]);

echo "Something went wrong (reference: {$errorRef}). Please try again later.";
```

---

## 10. Quick Checklist: Production-Safe DB Logging

When you move from development to production:

1. **Turn off** `display_errors`.
2. **Turn on** `log_errors` and set a dedicated `error_log` path.
3. **Use PDO exception mode** (`ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION`).
4. Wrap database operations in `try/catch` and **log details via `error_log()`**.
5. **Show generic messages** to users; no SQL, no internal file paths.
6. Sanitize logged parameters to avoid storing passwords or other sensitive data.
7. Ensure log files are **not accessible via the web** and are rotated regularly.

---

## 11. Closing

In this video, we focused on:

* The difference between development and production error handling
* Using PDO exceptions with `error_log()`
* Building a small logging helper
* Protecting sensitive data while still giving yourself enough information to debug

Together with the earlier videos on error types, error reporting, and debugging techniques, this gives you a practical foundation for running **database-driven PHP applications** in the real world.
