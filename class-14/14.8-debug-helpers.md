---
layout: default
title: 14.8 Using Prepared “Debug Helpers” for Logging Queries in Development with PHP 8.3
nav_order: 8
---

# 14.8 Using Prepared “Debug Helpers” for Logging Queries in Development with PHP 8.3

## **1. Opening**

So far in this series, we’ve learned how to configure error reporting, debug forms and sessions, work with exceptions, and debug database issues. In real-world projects, developers usually don’t scatter `var_dump()` and `echo` statements all over their code to inspect SQL queries or parameters. Instead, they use **centralized debug helpers**—small reusable functions that capture information automatically.

Today, we’ll introduce these helpers, show how they work, and explain how they make debugging faster and safer during development.

---

## **2. The Purpose of Debug Helpers**

When debugging database queries, students often need to answer questions like:

* *What SQL query actually ran?*
* *Which parameters were bound to it?*
* *Did the query execute successfully?*
* *If it failed, what was the exact exception message?*

Adding manual debug output everywhere gets messy. A **debug helper** allows you to drop one function call into your code and automatically log:

* The SQL statement
* The parameters
* Time the query took
* Any exception thrown

These helpers should be enabled only during development.

---

## **3. A Simple Development Flag**

Before we build helpers, we need a clean way to turn debugging on or off.

```php
// config.php
define('APP_DEBUG', true);   // change to false in production
```

This lets us centralize all “should we log this?” decisions.

---

## **4. Creating a Basic Query Logger**

Here’s a straightforward helper that logs SQL and parameters to a file during development.

### **File: `debug_helpers.php`**

```php
<?php

function logQuery(string $sql, array $params = []): void
{
    if (!APP_DEBUG) {
        return;
    }

    $message =
        "---- QUERY DEBUG ----\n" .
        "SQL: $sql\n" .
        "Params: " . var_export($params, true) . "\n" .
        "Timestamp: " . date('Y-m-d H:i:s') . "\n" .
        "----------------------\n";

    error_log($message, 3, __DIR__ . '/query_debug.log'); // 3 = append to file
}
```

**How it works:**

* Only runs when `APP_DEBUG` is true.
* Logs SQL and parameters in a human-readable format.
* Writes to a dedicated file so it doesn’t mix with PHP’s general error log.

---

## **5. Using the Helper with PDO**

Here’s how a typical query looks when combined with the helper:

```php
require 'config.php';
require 'debug_helpers.php';

$sql = "INSERT INTO orders (product, price, quantity)
        VALUES (:product, :price, :quantity)";

$params = [
    ':product' => $product,
    ':price' => $price,
    ':quantity' => $qty,
];

logQuery($sql, $params); // automatic debug logging

$stmt = $pdo->prepare($sql);
$stmt->execute($params);
```

The debug log now contains everything the developer needs to inspect.

---

## **6. Adding Timing Information (Measuring Query Speed)**

Sometimes debugging involves performance, not errors. We can extend the helper.

### **Improved Helper:**

```php
function logQueryWithTiming(string $sql, array $params, float $start, float $end): void
{
    if (!APP_DEBUG) {
        return;
    }

    $duration = number_format(($end - $start) * 1000, 2); // ms

    $message =
        "---- QUERY DEBUG ----\n" .
        "SQL: $sql\n" .
        "Params: " . var_export($params, true) . "\n" .
        "Duration: {$duration}ms\n" .
        "Timestamp: " . date('Y-m-d H:i:s') . "\n" .
        "----------------------\n";

    error_log($message, 3, __DIR__ . '/query_debug.log');
}
```

### **Usage:**

```php
$start = microtime(true);

$stmt = $pdo->prepare($sql);
$stmt->execute($params);

$end = microtime(true);

logQueryWithTiming($sql, $params, $start, $end);
```

Developers now get insight into performance as well as behavior.

---

## **7. Logging Exceptions Automatically**

Next, let’s create a helper designed for catching `PDOException`s in a standard format.

### **Exception Logging Helper**

```php
function logDbException(PDOException $e, string $sql, array $params = []): void
{
    if (!APP_DEBUG) {
        return;
    }

    $message =
        "---- PDO EXCEPTION ----\n" .
        "Message: " . $e->getMessage() . "\n" .
        "SQL: " . $sql . "\n" .
        "Params: " . var_export($params, true) . "\n" .
        "File: " . $e->getFile() . " (line " . $e->getLine() . ")\n" .
        "Trace: " . $e->getTraceAsString() . "\n" .
        "Timestamp: " . date('Y-m-d H:i:s') . "\n" .
        "------------------------\n";

    error_log($message, 3, __DIR__ . '/query_debug.log');
}
```

### **Usage with try/catch:**

```php
try {
    $stmt = $pdo->prepare($sql);
    $stmt->execute($params);
} catch (PDOException $e) {
    logDbException($e, $sql, $params);
    echo "An error occurred. Please try again later.";
    exit;
}
```

Now every exception is logged in a consistent, easy-to-read format.

---

## **8. Optional: A “Wrapper” Function to Automate All of This**

Advanced helpers can wrap PDO calls to centralize:

* Logging SQL
* Logging parameters
* Measuring execution time
* Catching exceptions

### **Example Wrapper:**

```php
function runQuery(PDO $pdo, string $sql, array $params = [])
{
    $start = microtime(true);

    try {
        $stmt = $pdo->prepare($sql);
        $stmt->execute($params);

        $end = microtime(true);

        logQueryWithTiming($sql, $params, $start, $end);

        return $stmt;
    } catch (PDOException $e) {
        logDbException($e, $sql, $params);
        throw $e; // rethrow so the caller can decide what to do
    }
}
```

### **Usage:**

```php
$stmt = runQuery($pdo, $sql, $params);
$orders = $stmt->fetchAll();
```

This approach creates a **central debugging gateway** for all database queries during development.

---

## **9. Why Debug Helpers Matter**

Benefits during development:

* You get a complete picture of what queries ran and why.
* You never have to add on-the-fly debug prints inside business logic.
* You don’t risk accidentally leaving debug code in production.
* Debug output is consistent across the entire codebase.
* You can filter or search logs easily when diagnosing problems.

When `APP_DEBUG` is false (production):

* Debug helpers turn themselves off, adding zero overhead.
* No SQL, parameters, or file paths are exposed to users.
* Logs remain clean and concise.

---

## **10. Closing**

Prepared “debug helpers” are a powerful tool for development. They allow you to:

* See every SQL query your application runs
* Inspect the parameters exactly as PDO receives them
* Log exceptions cleanly
* Measure query performance
* Keep production environments safe and quiet
* Keep debugging code out of your business logic

This becomes especially important as you build more complex, multi-page PHP applications — like the database-driven project described in this course.
