---
layout: default
title: 14.6 Debugging Forms, Sessions, and State in PHP 8.3
nav_order: 6
---

# 14.6 Debugging Forms, Sessions, and State in PHP 8.3

## 1. Opening

So far in this series, we’ve looked at:

* PHP error types and error reporting
* Practical debugging techniques
* Debugging database issues with PDO

In this video, we’ll connect those ideas to two very common problem areas:

1. **HTML forms** – reading and validating user input.
2. **Sessions and state** – keeping users logged in and maintaining data across requests.

We’ll focus on a few recurring problems and a repeatable process to track them down.

---

## 2. Debugging Form Handling – Start with the Basics

Most bugs in form handling come from a small set of issues:

* Wrong HTTP method (`GET` vs `POST`)
* Wrong input `name` attributes
* Missing validation or casting
* Assuming data exists when it doesn’t

### 2.1 Confirm the Method and Action

First, check the form:

```html
<form action="process_form.php" method="post">
    <input type="text" name="email">
    <button type="submit">Submit</button>
</form>
```

If the form uses `method="post"`, your PHP script should read from `$_POST`, not `$_GET`.

**Debugging step:**

At the top of `process_form.php`, during development:

```php
declare(strict_types=1);

error_reporting(E_ALL);
ini_set('display_errors', '1');

echo "<pre>";
echo "POST:\n";
var_dump($_POST);
echo "GET:\n";
var_dump($_GET);
echo "</pre>";
```

If `$_POST` is empty, either:

* The form is not submitting where you think it is.
* The form method doesn’t match what the script expects.
* There’s a redirect happening before you inspect the data.

---

### 2.2 Check `name` Attributes vs Array Keys

PHP uses the `name` attribute, not `id`.

Form:

```html
<input type="text" name="username">
```

Script:

```php
$username = $_POST['username'] ?? '';
```

If you use `$_POST['user']` by mistake, PHP will throw a notice (if error reporting is enabled):

```text
Notice: Undefined index: user
```

**Debugging step:**

When you see undefined index notices for form fields:

* Compare every `name="..."` in the HTML with every `$_POST['...']` in the script.
* Fix spelling and case differences.

---

### 2.3 Validate and Cast Input Before Use

In PHP 8.3, strict types and type hints make it easier to catch bad input, but you still need to validate and cast.

Example:

```php
function calculateTotal(float $price, int $quantity): float {
    return $price * $quantity;
}

$price    = isset($_POST['price']) ? (float) $_POST['price'] : 0.0;
$quantity = isset($_POST['quantity']) ? (int) $_POST['quantity'] : 0;
```

**Debugging step:**

If you see `TypeError` for a form-handling function:

* Dump the raw `$_POST` values.
* Check which values are empty strings, null, or unexpected types.
* Add casting and default values like above.

---

## 3. Debugging State with Sessions

Now let’s talk about debugging **sessions** and other state mechanisms.

Common complaints:

* “My login session doesn’t stick.”
* “The cart is always empty.”
* “`$_SESSION` is always empty.”

### 3.1 Always Call `session_start()` Before Using `$_SESSION`

In PHP, sessions are not available until you call:

```php
session_start();
```

This must happen **before any output** is sent to the browser.

**Debugging step:**

If `$_SESSION` always appears empty:

1. Check that `session_start()` is at the very top of the script or in a required config file that runs before output.

2. Turn on error reporting and watch for:

   ```text
   Warning: session_start(): Session cannot be started after headers have already been sent
   ```

3. If you see “headers already sent”:

   * Remove stray whitespace or BOM at the top of PHP files.
   * Make sure no `echo` or HTML appears before `session_start()`.

---

### 3.2 Inspect the Session Data

During development, it’s fine to dump session data:

```php
session_start();

echo "<pre>";
echo "SESSION:\n";
var_dump($_SESSION);
echo "</pre>";
```

If you expect `$_SESSION['user_id']` but it’s missing:

* Check the login script where you set it:

  ```php
  $_SESSION['user_id'] = $userId;
  ```
* Confirm that code actually runs (no early return, no failed database query).

---

### 3.3 Check the Session Cookie

Sessions rely on a cookie, usually named `PHPSESSID`.

If the browser isn’t accepting cookies or the cookie gets lost:

* Open your browser’s dev tools.
* Look under **Application → Cookies** (or similar).
* Confirm that a session cookie exists, and that it persists across requests.

**Debugging step:**

If the session works in one browser but not another, or only in private mode:

* Check cookie settings, domain, and path.
* Check for any custom session configuration in `php.ini` or `.htaccess`.

---

## 4. Combining Forms, Sessions, and Database Debugging

Let’s combine everything in a simple flow:

1. User submits a login form.
2. Script validates input and looks up the user in the database.
3. If successful, script stores `$_SESSION['user_id']` and redirects.

### 4.1 Example Flow (High Level)

**Form:**

```html
<form action="login.php" method="post">
    <label>
        Email:
        <input type="email" name="email">
    </label>
    <label>
        Password:
        <input type="password" name="password">
    </label>
    <button type="submit">Login</button>
</form>
```

**Script (login.php):**

```php
<?php
declare(strict_types=1);

session_start();
error_reporting(E_ALL);
ini_set('display_errors', '1');

// Quick debug: inspect POST
// echo "<pre>"; var_dump($_POST); echo "</pre>";

$email    = $_POST['email']    ?? '';
$password = $_POST['password'] ?? '';

if ($email === '' || $password === '') {
    die("Email and password are required.");
}

// Database lookup (PDO, exception mode)
$dsn = 'mysql:host=localhost;dbname=app;charset=utf8mb4';
$pdo = new PDO($dsn, 'user', 'pass', [
    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
]);

$sql = "SELECT id, password_hash FROM users WHERE email = :email";
$stmt = $pdo->prepare($sql);
$stmt->execute([':email' => $email]);
$user = $stmt->fetch();

if (!$user || !password_verify($password, $user['password_hash'])) {
    die("Invalid login.");
}

// Login success: store in session
$_SESSION['user_id'] = $user['id'];

// For debugging, check session
// echo "<pre>"; var_dump($_SESSION); echo "</pre>";

header("Location: dashboard.php");
exit;
```

**Potential bugs to debug:**

* Form not posting to the right file.
* Using `$_GET` instead of `$_POST`.
* Wrong column name in SQL (`email_address` vs `email`).
* Not starting the session before setting `$_SESSION['user_id']`.
* Redirect failing because headers were already sent.

**Debugging steps:**

* Dump `$_POST` to confirm data is arriving.
* Enable PDO exception mode and catch `PDOException`.
* Dump `$_SESSION` before redirect to confirm login state.
* Check for “headers already sent” warnings if redirects or sessions fail.

---

## 5. Debugging Other State Mechanisms: Query Strings and Cookies

Sessions are not the only state mechanism in PHP. You’ll also use:

* **Query strings** (e.g., `?page=2`)
* **Hidden form fields**
* **Cookies**

### 5.1 Query Strings

If a link looks like this:

```html
<a href="list.php?page=2">Next Page</a>
```

Then in PHP you read:

```php
$page = isset($_GET['page']) ? (int) $_GET['page'] : 1;
```

**Debugging step:**

If `$page` is always 1:

* Dump `$_GET` and confirm `page` is present.
* Check that the link URL actually includes `?page=...`.

---

### 5.2 Cookies

For debugging cookies:

```php
// Set cookie
setcookie('theme', 'dark', time() + 3600, '/');

// Later
echo "<pre>";
var_dump($_COOKIE);
echo "</pre>";
```

If the cookie never appears:

* Check that you’re setting the cookie before any output.
* Check path and domain parameters.
* Look in browser dev tools to see if the cookie is stored or blocked.

---

## 6. A Combined Debugging Checklist (Forms + Sessions + State)

When something involving forms or sessions isn’t working, run through this:

1. **Form data**

   * Is the form `method` correct?
   * Does the `action` point to the right script?
   * Do `name` attributes match `$_POST` or `$_GET` keys?

2. **Input validation and types**

   * Are you using `?? ''` or defaults for optional fields?
   * Are you casting numeric values before calculations or queries?

3. **Sessions**

   * Is `session_start()` called before any output?
   * Is the session cookie being set and persisted?
   * Is `$_SESSION` populated where you think it is?

4. **Database interaction**

   * Are you catching `PDOException` and reading the message?
   * Do your placeholders match the parameters you bind?
   * Have you tested the SQL directly in a database client?

5. **State via query strings/cookies**

   * Are query parameters present in the URL?
   * Are cookies being created, not blocked, and read with the right keys?

---

## 7. Closing

In this video, we combined several debugging techniques to handle:

* Form submission issues
* Session and state problems
* The interaction between forms, sessions, and database queries

The big idea is that **most bugs are about assumptions**: assuming data is there when it isn’t, assuming a session exists when it doesn’t, or assuming a query is correct when it has a typo. Debugging is the process of testing those assumptions, step by step.
