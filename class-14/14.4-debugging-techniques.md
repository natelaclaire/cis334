---
layout: default
title: 14.4 Practical Debugging Techniques in PHP 8.3
nav_order: 4
---

# 14.4 Practical Debugging Techniques in PHP 8.3

## 1. Opening

In this video, we’ll focus on **how to actually debug** when something goes wrong. We’ll walk through a simple, repeatable process and look at tools you can use directly in PHP 8.3.

By the end, you should have a mental checklist you can follow any time your script misbehaves.

---

## 2. General Debugging Mindset

Start with two ideas:

1. **Reproduce the problem clearly.**
   If you can’t reproduce it, you can’t reliably fix it.

2. **Change one thing at a time.**
   Don’t randomly edit ten lines and hope it works. Make small, controlled changes and test after each one.

We’ll use that mindset as we go through specific techniques.

---

## 3. Step 1 – Read the Error Message Carefully

When PHP shows an error (or logs one), don’t ignore the details. Look at:

* **Error type** (e.g., `TypeError`, `Warning`, `Notice`)
* **Message text** (what went wrong)
* **File and line number**
* **Stack trace** if available

Example message in PHP 8.x:

```text
Fatal error: Uncaught TypeError: multiply(): Argument #1 ($a) must be of type int, string given in /var/www/html/example.php:10
Stack trace:
#0 /var/www/html/index.php(5): multiply('10', 2)
#1 {main}
  thrown in /var/www/html/example.php on line 10
```

From this, you can immediately see:

* Which function failed (`multiply`).
* What was wrong (string instead of int).
* Where it was called (`index.php` line 5).

First step in your process: **identify the file, line, and specific complaint**.

---

## 4. Step 2 – Use Stack Traces to Find the Real Source

Stack traces show **the path of function calls** that led to the error. This is especially helpful in object-oriented code.

Key ideas:

* The **bottom** of the stack is usually where the error is thrown.
* The **lines above** tell you who called that function and with what values.

For exceptions, you can access the trace programmatically:

```php
try {
    doSomethingRisky();
} catch (Throwable $e) {
    echo $e->getMessage();
    echo "<pre>" . $e->getTraceAsString() . "</pre>";
}
```

Use the trace to answer: *“Where did this bad input come from?”*

---

## 5. Step 3 – Inspect Variables with `var_dump()` and `print_r()`

When the error message alone isn’t enough, inspect what data your script is working with.

Common functions:

* `var_dump($variable);` – shows type and value.
* `print_r($variable, true);` – readable value, often used for arrays.

Example:

```php
var_dump($_POST);
var_dump($user);
```

Tips:

* Add a clear label so you know what you’re looking at:

  ```php
  echo "<pre>POST data:\n";
  var_dump($_POST);
  echo "</pre>";
  ```
* In development, this is fine. In production, prefer logging instead of dumping to the browser.

---

## 6. Step 4 – Narrow Down the Problem (Isolation)

If the script is long, isolate the bug:

1. **Comment out sections** to see if the error goes away.
2. **Move suspicious code** into a small test script.
3. **Hard-code test values** instead of relying on form input or a database.

Example approach:

* If a form handler is failing, bypass the form:

  ```php
  $_POST = [
      'username' => 'testuser',
      'email' => 'test@example.com'
  ];
  ```

  Then run the script and see if it still breaks.

Isolation helps you separate “environment issues” (like bad input) from actual logic bugs.

---

## 7. Step 5 – Check Common Problem Areas

### a) Superglobals

Verify you’re using the correct superglobal:

* `$_GET` vs `$_POST`
* `$_SESSION` vs `$_COOKIE`

Example: You’re expecting `$_POST['email']` but the form uses `method="get"`. That will never work.

### b) Typos and Wrong Variable Names

Pay attention to:

* `$userName` vs `$username`
* `$result` vs `$results`

PHP is case-sensitive for variables, so `$User` and `$user` are different.

### c) Types and Casting

In PHP 8.3, type errors are stricter:

* Check function parameter types and return types.
* Use explicit casting when needed:

  ```php
  $age = (int) $_POST['age'];
  ```

---

## 8. Step 6 – Debugging Database-Related Bugs (Preview)

We’ll do a deeper database-focused video later, but here are quick techniques:

* **Display the actual SQL query** (in development only).
* **Check bound parameters** if using prepared statements.
* **Catch and inspect exceptions** from PDO:

```php
try {
    $stmt = $pdo->prepare($sql);
    $stmt->execute($params);
} catch (PDOException $e) {
    echo "Database error: " . htmlspecialchars($e->getMessage());
}
```

Often the problem is a typo in a column name or a mismatch between placeholder names and array keys.

---

## 9. Step 7 – Use Logging for Persistent or Hard-to-Reproduce Bugs

Instead of printing debug info to the browser, log it:

```php
error_log('Reached checkpoint A in processOrder().');
error_log('User data: ' . print_r($userData, true));
```

This is helpful when:

* The bug only appears sometimes.
* You can’t sit and watch the browser output.
* You’re debugging on a remote server.

Logs let you trace what happened over time.

---

## 10. Optional: Using Xdebug and IDE Tools (High-Level Mention)

PHP 8.3 works well with Xdebug and modern IDEs. At a high level, these tools let you:

* Set breakpoints.
* Inspect variables at each line.
* Step through code line by line.

You don’t need these tools to start debugging, but they’re worth learning once you’re comfortable with the basics covered here.

---

## 11. A Simple Debugging Checklist

To summarize, when something breaks:

1. **Reproduce the error.**
2. **Read the error message and stack trace.**
3. **Inspect key variables with `var_dump()` or logging.**
4. **Isolate the problem area by simplifying the script.**
5. **Check common issues**: wrong superglobal, typos, type mismatches.
6. **Log additional information** if the bug is intermittent.

This gives you a predictable, repeatable way to tackle bugs, rather than guessing.

---

## 12. Closing

In this video, we focused on practical debugging techniques you can apply right away in your PHP 8.3 projects. By following a systematic approach, you can quickly identify and fix issues in your code.
