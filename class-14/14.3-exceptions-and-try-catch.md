---
layout: default
title: 14.3 Exceptions and try…catch in PHP
nav_order: 3
---

# 14.3 Exceptions and try…catch in PHP

## **1. Opening**

Up to this point, we’ve talked about PHP errors, warnings, and notices — and how to configure error reporting. Now we’ll shift to an important tool modern PHP uses to handle problems in a controlled, predictable way: **exceptions**.

Exceptions let you catch errors as they happen, decide what to do about them, and keep your application from crashing in unpredictable ways. PHP 8.3 uses exceptions widely, especially with strict typing, password functions, object-oriented programming, and PDO database access.

---

## **2. What Is an Exception?**

An exception is PHP’s way of saying:

> “Something went wrong right here. If you want to handle it, you can. Otherwise, I’m stopping the script.”

Instead of showing a fatal error immediately, PHP lets you catch the problem using a `try…catch` block.

---

## **3. Basic `try…catch` Structure**

The basic pattern looks like this:

```php
try {
    // Code that might fail
    riskyFunction();
} catch (Exception $e) {
    // Code to run if an exception occurs
    echo "Something went wrong: " . $e->getMessage();
}
```

Inside the `try` block, PHP runs instructions normally.
If one of those instructions throws an exception:

* PHP jumps to the matching `catch` block.
* The exception object (`$e`) contains information about what went wrong.

Your script does not stop unless you choose to stop it.

---

## **4. What Can Throw Exceptions?**

In PHP 8.3, many language features and functions can throw exceptions:

* Strict type violations: `TypeError`, `ArgumentCountError`, `ValueError`
* PDO when using `ERRMODE_EXCEPTION`
* JSON operations like `json_decode()` when `JSON_THROW_ON_ERROR` is enabled
* Filesystem functions in certain contexts
* Your own code using `throw`

Across modern PHP, exceptions are the standard way to handle serious, recoverable errors.

---

## **5. A Practical Example**

Here’s a simple example that triggers an exception using strict type checks:

```php
<?php
declare(strict_types=1);

function multiply(int $a, int $b): int {
    return $a * $b;
}

try {
    echo multiply("10", 5); // WRONG: "10" is a string
} catch (TypeError $e) {
    echo "TypeError caught: " . $e->getMessage();
}
```

**What’s happening:**

* `multiply("10", 5)` breaks strict typing.
* PHP throws a `TypeError`.
* The catch block handles it cleanly instead of producing a fatal error.

---

## **6. Multiple Catch Blocks**

You can catch different exception types differently:

```php
try {
    processInput($data);
} catch (ValueError $e) {
    echo "Invalid value: " . $e->getMessage();
} catch (TypeError $e) {
    echo "Type mismatch: " . $e->getMessage();
} catch (Exception $e) {
    echo "General error: " . $e->getMessage();
}
```

PHP checks catch blocks from top to bottom.
Use more specific exception types first, then broader types like `Exception` or `Throwable`.

---

## **7. The `Throwable` Interface**

All exceptions in PHP implement the `Throwable` interface, so you can catch *anything* using:

```php
catch (Throwable $e)
```

This catches both:

* `Exception`
* `Error` (e.g., fatal errors represented as Error objects)

This is useful when you need a single fallback handler—for example, logging errors in production.

---

## **8. Throwing Your Own Exceptions**

You can raise an exception manually when your code hits an unexpected condition:

```php
function divide(int $a, int $b): float {
    if ($b === 0) {
        throw new ValueError("Cannot divide by zero.");
    }
    return $a / $b;
}

try {
    echo divide(10, 0);
} catch (ValueError $e) {
    echo "Caught exception: " . $e->getMessage();
}
```

This helps you enforce rules, validate data, or prevent invalid states.

---

## **9. Common Exceptions in PHP 8.3**

Here are the ones students will encounter most often:

### **TypeError**

Thrown when a value has the wrong type.

Example triggers:

* Function received a string instead of an integer
* Method return type doesn’t match declared type
* Null passed where a non-nullable parameter is required

---

### **ArgumentCountError**

Thrown when you pass too many or too few arguments to a function.

```php
strlen("abc", "extra"); // ArgumentCountError
```

---

### **ValueError**

Thrown when the type is correct but the **value** is not acceptable.

Examples:

* Negative length in `str_repeat()`
* Invalid JSON depth
* `0` passed into a function that expects a positive integer
* Dividing by zero in your own code when you throw a ValueError

---

### **PDOException**

Thrown when database operations fail while in exception mode.

Examples:

* SQL syntax errors
* Missing table or column
* Bad parameter bindings
* Connection failures

Students will see this often in database homework.

---

### **Error and its subclasses**

Not all "hard failures" are recoverable exceptions, but PHP models many of them as objects:

* `Error`
* `ParseError`
* `DivisionByZeroError`
* `AssertionError`

You can catch them with:

```php
catch (Error $e)
```

or the broader:

```php
catch (Throwable $e)
```

---

## **10. Why Use Exceptions Instead of Relying on Fatal Errors?**

Exceptions give you **control**.

Instead of PHP stopping your program abruptly:

* You can log the error.
* You can show a safe, generic message.
* You can respond gracefully (redirect, show form errors, etc.).
* Your script doesn’t crash unexpectedly.

This is especially important for:

* Login systems
* Database operations
* File uploads
* Payment processing
* Multi-step forms
* APIs

---

## **11. A Simple, Clean try/catch Template for Students**

This template works for most situations:

```php
try {
    // 1. Validate input
    // 2. Run database queries
    // 3. Perform calculations
    // 4. Write to files or external APIs
} catch (Throwable $e) {
    // Production-safe logging
    error_log("Error in " . __FILE__ . ":" . __LINE__ . " – " . $e->getMessage());
    
    // Generic message for the user
    echo "Something went wrong. Please try again.";
}
```

This helps prevent:

* Blank white screens
* Uncaught fatal errors
* Sensitive information leaking
* Confusing error messages for users
* Hard-to-debug production issues

---

## **12. Closing**

In this video, we introduced:

* What exceptions are
* How try…catch works
* How to throw and catch exceptions
* When to use multiple catch blocks
* The most common exception types in PHP 8.3

Understanding this foundation will make all the later debugging videos much clearer — especially the ones about database debugging, logging, and error handling in production environments. Exceptions are the backbone of modern PHP error handling, and mastering them will help you write cleaner, safer, more predictable code.
