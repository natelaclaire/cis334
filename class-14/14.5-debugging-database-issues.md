---
layout: default
title: 14.5 Debugging Database Issues with PDO
nav_order: 5
---

# 14.5 Debugging Database Issues with PDO

## 1. Opening

In previous videos we talked about:

* PHP error types
* Error reporting and `display_errors`
* General debugging techniques

In this video, we’ll zoom in on **database-specific debugging** with PDO and MySQL. We’ll look at how to:

* See meaningful database error messages
* Catch and inspect `PDOException`s
* Identify common SQL and parameter binding mistakes
* Safely inspect queries and parameters

By the end, you should have a clear process for tracking down “mystery” database bugs.

---

## 2. Make Sure PDO Is in Exception Mode

First, we want PDO to throw exceptions when something goes wrong. In PHP 8.3, this is the most useful setting for debugging.

### Example: proper PDO setup

```php
<?php
declare(strict_types=1);

$dsn = 'mysql:host=localhost;dbname=mydb;charset=utf8mb4';
$user = 'root';
$pass = 'mariadb';

try {
    $pdo = new PDO($dsn, $user, $pass, [
        PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,  // key line
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    ]);
} catch (PDOException $e) {
    // In production, log instead of echo
    die("Database connection failed: " . htmlspecialchars($e->getMessage()));
}
```

If `ATTR_ERRMODE` is not set to `EXCEPTION`, PDO may just return `false` from queries with very little information.

---

## 3. Catching and Inspecting `PDOException`

Whenever you run queries that might fail, wrap them in a `try/catch`. This lets you see:

* The error message
* The SQLSTATE code
* The file and line where the error occurred

### Example:

```php
$sql = "INSERT INTO orders (product, price, quantity, total)
        VALUES (:product, :price, :quantity, :total)";

try {
    $stmt = $pdo->prepare($sql);
    $stmt->execute([
        ':product'  => $product,
        ':price'    => $price,
        ':quantity' => $quantity,
        ':total'    => $total,
    ]);
} catch (PDOException $e) {
    echo "<h2>Database Error</h2>";
    echo "<p>Message: " . htmlspecialchars($e->getMessage()) . "</p>";
    // For teaching/demo, you could also:
    // echo "<pre>" . $e->getTraceAsString() . "</pre>";
}
```

In a real application you would log this to a file instead of showing it to users, but during development it’s useful to see it.

---

## 4. Common PDO Error Patterns and How to Debug Them

### a) “Invalid parameter number” / Mismatched placeholders

One of the most common errors:

```text
SQLSTATE[HY093]: Invalid parameter number: parameter was not defined
```

This usually means the named placeholders in your SQL don’t match the keys you pass to `execute()`.

**Example bug:**

```php
$sql = "INSERT INTO orders (product, price, quantity)
        VALUES (:product, :price, :quantity)";

$stmt = $pdo->prepare($sql);

$stmt->execute([
    ':product' => $product,
    ':price'   => $price,
    ':qty'     => $quantity,  // BUG: should be :quantity
]);
```

**Debugging steps:**

1. Compare every `:placeholder` in the SQL string with the array keys.
2. Make sure the names match *exactly* (case-sensitive).
3. Check that you didn’t accidentally reuse the same name twice with different meanings.

---

### b) “Unknown column” or “Unknown table”

Errors like:

```text
SQLSTATE[42S22]: Column not found: 1054 Unknown column 'prce' in 'field list'
```

Usually a typo or a mismatch between the database schema and your query.

**Debugging steps:**

1. Copy the SQL from your code into a tool like `mysql` CLI or phpMyAdmin.
2. Run it directly against the database.
3. Compare the table definition to the column names in your query.

If it works in the database client but not in PHP, you may be binding the wrong values or using a different database than you think.

---

### c) “Syntax error” in SQL

If MySQL reports a syntax error, the error message often includes the spot where it got confused.

**Debugging steps:**

1. Echo or log the **final SQL query** (for dev only).
2. Run that exact SQL in a database client.
3. Adjust until it runs there, then bring the fixed SQL back into your PHP script.

---

## 5. Safely Inspecting SQL and Parameters

You never want to dump raw SQL with user input on a production site, but in development it’s very helpful.

### Example: debugging output (development only)

```php
echo "<pre>";
echo "SQL:\n" . $sql . "\n\n";
echo "Parameters:\n";
var_dump($params);
echo "</pre>";
```

You can set this behind a simple flag:

```php
$debug = true;  // development only

if ($debug) {
    echo "<pre>";
    echo "SQL:\n" . $sql . "\n\n";
    echo "Parameters:\n";
    var_dump($params);
    echo "</pre>";
}
```

This lets you verify things like:

* Did I bind all the required placeholders?
* Are the data types what I expect?
* Did I accidentally bind `null` because I used the wrong `$_POST` key?

---

## 6. Debugging `execute()` Returning `false` (Non-exception mode)

If you ever work in code that doesn’t use exception mode, `execute()` might just return `false`.

You can still check the error info:

```php
if (!$stmt->execute($params)) {
    $errorInfo = $stmt->errorInfo();
    // $errorInfo[0] = SQLSTATE code
    // $errorInfo[1] = driver-specific error code
    // $errorInfo[2] = driver-specific error message
    echo "<pre>";
    var_dump($errorInfo);
    echo "</pre>";
}
```

But the recommended approach is still to **turn on exception mode** and handle `PDOException`.

---

## 7. Debugging Data Issues (Not Just SQL)

Sometimes the query is valid, but the data isn’t what you think it is.

### Techniques:

* `var_dump($params)` before `execute()`
* Check casting and sanitizing of inputs:

  ```php
  $price    = isset($_POST['price']) ? (float) $_POST['price'] : 0.0;
  $quantity = isset($_POST['quantity']) ? (int) $_POST['quantity'] : 0;
  ```
* Verify foreign keys and IDs exist before inserting or updating.

Ask yourself:

* Does this ID actually exist in the related table?
* Is this column allowed to be NULL?
* Does this value violate a unique constraint?

Database errors like:

```text
SQLSTATE[23000]: Integrity constraint violation
```

often point to these issues.

---

## 8. Debugging SELECT Queries and Fetching Data

Sometimes the query runs fine, but you don’t get the data you expect.

### Checklist:

1. **Check the WHERE clause.** Are you using the right column names and comparison operators?
2. **Check bound parameters.** Is the value you’re filtering by the one you think it is?
3. **Verify fetch mode.** If you use `PDO::FETCH_ASSOC`, you should access columns as `$row['column_name']`, not `$row[0]`.

### Example:

```php
$sql = "SELECT id, product, price FROM orders WHERE product = :product";
$stmt = $pdo->prepare($sql);
$stmt->execute([':product' => $product]);

$rows = $stmt->fetchAll();  // default mode is set in PDO

echo "<pre>";
var_dump($rows);
echo "</pre>";
```

If `$rows` is an empty array, either:

* No data matches that condition, or
* You’re filtering with the wrong value.

Dump `$product` and confirm it holds what you expect.

---

## 9. Transactions and Debugging Multiple Queries

When you run multiple related queries, use transactions so you don’t leave the database in a half-updated state.

Transactions can also help debugging by ensuring you don’t commit bad data while testing.

### Example:

```php
try {
    $pdo->beginTransaction();

    // First query
    $stmt1 = $pdo->prepare($sql1);
    $stmt1->execute($params1);

    // Second query
    $stmt2 = $pdo->prepare($sql2);
    $stmt2->execute($params2);

    $pdo->commit();
} catch (PDOException $e) {
    $pdo->rollBack();
    echo "Transaction failed: " . htmlspecialchars($e->getMessage());
}
```

If an error occurs, everything is rolled back, and you can safely rerun debugging tests without corrupting data.

---

## 10. A Simple Database Debugging Checklist

When your database code misbehaves:

1. **Confirm exception mode is on** (`PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION`).
2. **Wrap queries in a `try/catch` and inspect `PDOException` messages.**
3. **Compare SQL placeholders to bound parameters** (names must match).
4. **Test the SQL directly in a database client** with sample values.
5. **Dump/log parameters** to confirm their values and types.
6. **Check schema-related issues**: column names, types, constraints, foreign keys.
7. **Use transactions** when multiple queries must all succeed or fail together.

Following this list will save a lot of time when you’re working with form handlers and dynamic, database-driven pages.

---

## 11. Closing

In this video we focused on debugging PDO and MySQL issues in PHP 8.3:

* You saw how to get meaningful error messages with exception mode.
* You learned how to track down common errors like parameter mismatches and unknown columns.
* You saw practical ways to inspect queries and parameters safely.
