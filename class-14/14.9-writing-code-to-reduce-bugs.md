---
layout: default
title: 14.9 Writing PHP Code That Prevents Errors (PHP 8.3)
nav_order: 9
---

# 14.9 Writing PHP Code That Prevents Errors (PHP 8.3)

## 1. Opening

So far in this series we’ve focused on what happens **after** things go wrong:

* Error types
* Error reporting
* Debugging techniques
* Exceptions and logging

In this video, we’ll flip that around and talk about **how to write PHP code that avoids many errors from the start**.

We’ll look at practical habits you can use in every assignment and project:

* Using types and strict mode
* Validating input early
* Writing small, focused functions
* Handling “edge cases” on purpose
* Being defensive with database and session code
* Using consistent coding style and automated checks

The goal is simple: fewer surprises, fewer bugs, and easier debugging when something *does* go wrong.

---

## 2. Use Strict Types and Type Declarations

Type-related bugs are some of the most common in PHP. PHP 8.3 gives you strong tools to catch them early.

### 2.1 Enable strict types

At the top of your PHP files:

```php
<?php
declare(strict_types=1);
```

This tells PHP to **enforce** parameter and return types instead of silently converting values. It might feel strict at first, but it forces you to be precise and prevents subtle bugs.

### 2.2 Use parameter and return types

```php
function calculateTotal(float $price, int $quantity): float {
    return $price * $quantity;
}
```

Benefits:

* PHP catches incorrect usage as `TypeError` instead of giving weird results.
* Your function’s “contract” is clear to anyone reading the code.

---

## 3. Validate Input Early (Fail Fast)

Never trust external input:

* Form data (`$_POST`, `$_GET`)
* Query strings
* Cookies
* JSON from APIs
* Anything from the database that you didn’t generate yourself

### 3.1 Example: validating form data

```php
$price    = filter_input(INPUT_POST, 'price', FILTER_VALIDATE_FLOAT);
$quantity = filter_input(INPUT_POST, 'quantity', FILTER_VALIDATE_INT);

if ($price === false || $quantity === false || $quantity <= 0) {
    die("Invalid price or quantity.");
}

$total = calculateTotal($price, $quantity);
```

You:

* Validate and sanitize data immediately.
* Refuse to continue with bad data.
* Prevent later errors like division by zero, nonsense totals, or TypeErrors.

This is “fail fast”: stop early when something is clearly wrong.

---

## 4. Write Small, Focused Functions

Long functions with lots of responsibilities are error-prone and hard to debug. Aim for functions that “do one thing well.”

### 4.1 Example: instead of one giant function

Bad pattern:

```php
function processOrder() {
    // read form data
    // validate data
    // connect to DB
    // calculate total
    // insert into DB
    // send email
    // render response
}
```

Better pattern (high level):

```php
function getOrderInput(): array { /* ... */ }
function validateOrder(array $data): void { /* ... */ }
function saveOrder(PDO $pdo, array $data): int { /* ... */ }
function sendOrderEmail(array $data): void { /* ... */ }
```

Benefits:

* Less chance of mixing responsibilities or forgetting steps.
* Easier to test each piece.
* When something breaks, you know where to look.

---

## 5. Use Guard Clauses Instead of Deep Nesting

Deeply nested `if` statements make code hard to read and reason about.

### 5.1 Example: before (deep nesting)

```php
if ($user) {
    if ($user['active']) {
        if ($user['role'] === 'admin') {
            // do something
        } else {
            // error
        }
    } else {
        // error
    }
} else {
    // error
}
```

### 5.2 After (guard clauses)

```php
if (!$user) {
    die("User not found.");
}

if (!$user['active']) {
    die("Account is inactive.");
}

if ($user['role'] !== 'admin') {
    die("Access denied.");
}

// do something
```

Guard clauses:

* Handle invalid or edge cases **up front**.
* Keep the main logic flat and easy to read.
* Reduce mistakes in complicated nesting.

---

## 6. Be Defensive with Database Code

Database errors often come from assumptions:

* Wrong column name
* Missing parameter
* Unexpected null value

### 6.1 Always use prepared statements with named parameters

```php
$sql = "INSERT INTO orders (product, price, quantity, total)
        VALUES (:product, :price, :quantity, :total)";

$params = [
    ':product'  => $product,
    ':price'    => $price,
    ':quantity' => $quantity,
    ':total'    => $total,
];

$stmt = $pdo->prepare($sql);
$stmt->execute($params);
```

### 6.2 Check for missing data before executing

```php
if ($product === '' || $price <= 0 || $quantity <= 0) {
    die("Invalid order data.");
}
```

### 6.3 Use exception mode and catch it

```php
$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

try {
    $stmt->execute($params);
} catch (PDOException $e) {
    // log error, show safe message
}
```

This combination prevents many “silent failure” bugs.

---

## 7. Handle Sessions and State Deliberately

Session bugs are often caused by small oversights:

* Forgetting `session_start()`
* Starting the session after output
* Assuming a session value exists when it doesn’t

### 7.1 Always start sessions early

```php
<?php
declare(strict_types=1);
session_start();

// rest of code
```

### 7.2 Check for required session values

```php
if (!isset($_SESSION['user_id'])) {
    // redirect to login
    header("Location: login.php");
    exit;
}
```

This prevents “undefined index” notices and logic errors around login and access control.

---

## 8. Use Defaults and Null Coalescing

Unset or missing array keys are a common source of bugs.

### 8.1 Null coalescing operator (`??`)

```php
$page = $_GET['page'] ?? 1;
```

### 8.2 Safe access for optional fields

```php
$searchTerm = trim($_GET['q'] ?? '');
```

This avoids undefined index notices and makes behavior predictable.

---

## 9. Avoid “Magic Numbers” and Strings

Using raw values scattered throughout code leads to mistakes.

### 9.1 Use constants instead of magic values

```php
const ROLE_ADMIN = 'admin';
const ROLE_USER  = 'user';

if ($user['role'] === ROLE_ADMIN) {
    // admin area
}
```

Benefits:

* Less chance of typos
* Easier to update values in one place
* Code is more self-documenting

---

## 10. Adopt a Consistent Coding Style

Inconsistent naming and formatting don’t just look messy—they lead to mistakes.

### 10.1 Simple guidelines

* Use clear, descriptive variable names (`$orderTotal`, not `$ot`)
* Use consistent casing (e.g., `$camelCase` for variables)
* Indent blocks consistently
* Keep functions short and focused

### 10.2 Use tools where possible

Even if you don’t go all the way to full automated tooling, you can:

* Use IDEs or editors with PHP linting
* Run `php -l filename.php` to check syntax

Small style improvements reduce cognitive load and help you notice real issues.

---

## 11. Add Lightweight Automated Checks

You don’t need full “enterprise” testing to get value from automated checks.

### 11.1 Start with syntax and types

* Use `declare(strict_types=1);`
* Use `php -l` to check syntax errors
* If you use an IDE, pay attention to warnings and hints

### 11.2 Gradually add small tests

Even simple test scripts that call your functions with sample data help you:

* Confirm correct behavior
* Prevent regressions when you change code later

---

## 12. Think About Errors *While* You Design

A big mindset shift is this:

> Don’t add error handling at the end. Design with errors in mind from the beginning.

Ask yourself as you write each function:

* What if this input is missing?
* What if this database query returns no rows?
* What if this value is zero or negative?
* What if the user is not logged in?

If you handle these questions in your design, many bugs never appear.

---

## 13. Closing

In this video, we looked at **preventing** errors, not just fixing them:

* Types and strict mode
* Validating input early
* Small, focused functions and guard clauses
* Defensive database and session handling
* Using defaults and avoiding magic values
* Consistent style and simple automated checks

You won’t prevent every bug, but these habits dramatically reduce how often you run into mysterious issues—and they make debugging much easier when something does go wrong.

In your upcoming assignments and projects, try to:

* Turn on strict types
* Add input validation as the first step in your scripts
* Break large tasks into small, well-named functions
* Use sessions and database code defensively

---

## PHP Error-Prevention Checklist (PHP 8.3)

Here's a handy checklist to follow when writing PHP code to reduce bugs:

### 1. File Setup

* [ ] Start each file with:

  ```php
  <?php
  declare(strict_types=1);
  ```
* [ ] Turn on full errors in development (not production):

  ```php
  error_reporting(E_ALL);
  ini_set('display_errors', '1');
  ```

---

### 2. Functions and Types

* [ ] Every function has **parameter types** and a **return type**:

  ```php
  function calculateTotal(float $price, int $quantity): float { ... }
  ```
* [ ] Functions are **short** and **do one thing**.
* [ ] No giant “god functions” that handle input, DB, business logic, and output all at once.

---

### 3. Input Handling (Forms, Query Strings, etc.)

For each external input (`$_POST`, `$_GET`, JSON, etc.):

* [ ] Use `??` or `filter_input()` instead of assuming keys exist:

  ```php
  $page = (int) ($_GET['page'] ?? 1);
  ```
* [ ] Validate **type** and **range**:

  * [ ] Numbers are cast and checked (e.g., `> 0`).
  * [ ] Required fields are not empty.
* [ ] Reject bad input early (“fail fast”):

  ```php
  if ($price <= 0 || $quantity <= 0) {
      die("Invalid price or quantity.");
  }
  ```

---

### 4. Sessions and State

* [ ] `session_start()` is called **at the very top** of scripts that use `$_SESSION` (before any HTML/output).
* [ ] Access control checks use `isset()`:

  ```php
  if (!isset($_SESSION['user_id'])) {
      header("Location: login.php");
      exit;
  }
  ```
* [ ] You do not assume session keys exist without checking.

---

### 5. Database Code (PDO)

* [ ] PDO is in exception mode:

  ```php
  $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
  ```
* [ ] Every query uses **prepared statements** with **named placeholders**:

  ```php
  $sql = "SELECT * FROM users WHERE email = :email";
  ```
* [ ] Placeholders in SQL and parameter array **match exactly**:

  ```php
  $params = [':email' => $email];
  ```
* [ ] You validate inputs **before** executing the query.
* [ ] Query execution is wrapped in `try { ... } catch (PDOException $e) { ... }` (and logged in real apps).

---

### 6. Exceptions and Error Handling

* [ ] Any code that can fail in a meaningful way is wrapped in `try…catch`:

  ```php
  try {
      // risky code
  } catch (Throwable $e) {
      // log + friendly message
  }
  ```
* [ ] You catch **specific** exception types when it makes sense (`TypeError`, `ValueError`, `PDOException`).
* [ ] User-facing messages are generic; detailed error info goes to logs (in real apps).

---

### 7. Guard Clauses and Edge Cases

For each function or script:

* [ ] You handle **invalid or edge cases first**, then the “happy path”:

  ```php
  if ($quantity <= 0) {
      die("Quantity must be positive.");
  }
  // main logic below
  ```
* [ ] You’ve considered:

  * [ ] Empty form submissions
  * [ ] Missing or invalid IDs
  * [ ] Empty query results
  * [ ] Division by zero
  * [ ] Null or optional fields

---

### 8. Arrays, Defaults, and “Magic” Values

* [ ] No `Undefined index` warnings:

  * Always use `??` or `isset()` before reading array keys.
* [ ] Use constants instead of “magic strings/numbers”:

  ```php
  const ROLE_ADMIN = 'admin';
  ```
* [ ] Default values are clear and intentional:

  ```php
  $sort = $_GET['sort'] ?? 'date';
  ```

---

### 9. Style and Readability

* [ ] Variable names are descriptive (no `$x`, `$y`, `$tmp` for important data).
* [ ] Indentation is consistent; blocks are easy to scan.
* [ ] Long blocks are broken into helper functions.
* [ ] Repeated code is moved into a function instead of copy/pasted.

---

### 10. Before You Call It “Done”

For each script/page:

* [ ] **Syntax check** passes:

  ```bash
  php -l your_script.php
  ```
* [ ] With test inputs, there are **no notices, warnings, or fatal errors** in development.
* [ ] You’ve tried at least **one “bad” input** (missing field, wrong type, etc.) to see how your code behaves.
* [ ] Any `var_dump()` / debug `echo` calls used while coding have been removed or wrapped in a debug flag.
