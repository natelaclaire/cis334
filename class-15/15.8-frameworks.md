---
layout: default
title: 15.8 Overview of Common PHP Frameworks and the Design Patterns Behind Them
nav_order: 8
---

# 15.8 Overview of Common PHP Frameworks and the Design Patterns Behind Them

In this final video, we’re going to step back and look at the bigger picture. You’ve spent the week learning how design patterns help you write cleaner and more reusable code. Now let’s see how those same ideas show up in the major PHP frameworks used today.

Even if you haven’t worked with a framework before, you’ll recognize many of the structures because they’re based on the patterns we’ve already covered.

---

## **Why Frameworks Matter**

Frameworks give you a foundation for building applications. You don’t have to invent routing, controllers, templates, database layers, or security features. The framework provides organized, predictable structures so you can focus on your application’s logic.

And at the core of each framework are the same design patterns you now understand.

---

## **Laravel**

Let’s start with [**Laravel**](https://laravel.com/), currently the most popular PHP framework.

Laravel uses several patterns you’ve seen:

* **MVC** as the main organizational structure
* **Singleton** for shared services inside the "service container"
* **Factory** patterns when resolving objects from the container
* **Strategy** in authentication, mail drivers, queue drivers, and more
* **Observer** in the Eloquent ORM, where you can watch for model events

Laravel’s design encourages clean separation of roles. Models handle data and relationships, controllers respond to requests, and views render templates. When you use Laravel, you’re using patterns constantly—often without realizing it.

---

## **Symfony**

Next is [**Symfony**](https://symfony.com/), a powerful framework that many other tools are built on—including parts of Laravel.

Symfony leans heavily on:

* **Dependency Injection**, which is a structured version of the same ideas behind Strategy and Factory patterns
* **Event Dispatcher**, which is another example of the **Observer** pattern
* **Service Container**, which centralizes object creation using **Singleton-like** behavior and **Factories**
* **MVC**, though Symfony allows flexibility in how you structure the layers

Symfony is known for its strict organization and reusable components. If you understand the patterns, learning Symfony becomes much easier.

---

## **CodeIgniter**

[CodeIgniter](https://codeigniter.com/) is lightweight and easy to get started with. It uses:

* **MVC** for basic structure
* A simplified **Factory** approach for loading libraries
* Some **Singleton** behavior for core classes like the database object

It doesn’t enforce as much structure as Laravel or Symfony, which can be helpful for new developers. But the patterns are still there—they just show up in a simpler way.

---

## **CakePHP**

[**CakePHP**](https://cakephp.org/) is another long-standing framework with a focus on convention over configuration.

You’ll see:

* **MVC**
* **ORM events**, again a form of the **Observer** pattern
* **Factory** methods for creating table classes and model objects

CakePHP emphasizes configuration-by-convention, which reduces boilerplate. Following conventions is easier when the framework uses familiar patterns.

---

## **Slim**

[Slim](https://www.slimframework.com/) is a micro-framework. It is minimal, fast, and perfect for APIs.

It relies on:

* **Routing + Controller patterns**
* **Dependency Injection**, which uses **Factory** and **Strategy** concepts
* Optional view layers you can plug in

You won’t see as many built-in tools, but the pattern foundation is the same.

---

## **How This Ties Back to Your Design Patterns**

The key takeaway is that frameworks aren’t magic. They’re organized collections of the patterns we’ve been studying:

* **MVC** shapes the overall structure.
* **Singleton** and **Factory** patterns control how shared services are created.
* **Strategy** allows swappable behaviors, like drivers for caching, storage, logging, or authentication.
* **Observer** keeps parts of the application updated when something changes.

When you recognize these patterns in a framework, you’ll understand why it works the way it does. That makes learning new frameworks much easier, and it makes you a better developer because you can predict how components fit together.

---

## **Closing**

As you continue building PHP applications, frameworks will become a natural next step. You now know the design patterns that power them, and that knowledge will help you work with any tool—Laravel, Symfony, CakePHP, or something entirely new.

This wraps up our series on reusable design patterns. You’ve built a strong foundation for writing scalable, maintainable PHP applications. Great work, and I look forward to seeing what you create.
