---
layout: default
title: 2.2 Defining Custom Classes
nav_order: 3
---

# 2.2 Defining Custom Classes (pages 573-587)

## A Simple Class Definition

In PHP, you define a class with the `class` keyword:

```php
class User
{

}
```

A class may be declared in any PHP file, although we'll see that to improve the maintainability of our code, we often define each class in its own file, with the filename matching the class name plus `.php`.

PHP class names are case‑insensitive, but remember that filenames on many platforms are case-sensitive, so given what i just shared, it is common to treat class names as if they were case-sensitive. PHP class names must start with a letter or underscore, followed by any number of letters, numbers, or underscores. They cannot be [reserved words](https://www.php.net/manual/en/reserved.php).

Although not required by the language itself, the [PHP Framework Interop Group](https://www.php-fig.org/)'s [PSR-1: Basic Coding Standard](https://www.php-fig.org/psr/psr-1/) requires that class names be declared in **StudlyCaps** (first letter of each word capital, including the first word).

A class may contain **constants**, **properties** and **methods**, which are together known as **class members**. While the book makes a distinction between the terms for these members on the class vs. an object on page 573, this distinction isn't very common. Properties are sometimes referred to as fields and methods are sometimes referred to as functions.

---

## Defining Class Members

In PHP 8.3, we can now define all class members using a visibility modifier and a type (or return type for methods). Let's look at an example:

```php
class User
{
    public const string ADMIN = 'admin';
    public const string USER = 'user';

    private int $id;
    protected string $firstName;
    protected string $userType = self::USER;

    private static int $nextId = 0;
    
    public function getId(): int
    {
        return $this->id;
    }

    public function setFirstName(string $firstName): void
    {
        $this->firstName = $firstName;
    }

    public static function getNextId(): int
    {
        return self::nextId++;
    }
}
```

In PHP you control access using **visibility modifiers**, sometimes called **access specifiers**: `public` members are accessible from anywhere; `protected` members are accessible within the class and its subclasses (part of inheritance, which we'll get to); and `private` members are accessible only within the class that defines them. If you don’t specify a visibility for a property, method, or constant, it is public by default.

Visibility modifiers are related to **information hiding** and **encapsulation**, allowing the class to control who has what access to data.

Most methods operate on an object instance and use `$this` to refer to the current object. Keep in mind that, in this example, there could be several objects instantiated from the User class. When `$userObject->setFirstName('Bob')` is called, for example, the name "Bob" is stored in the `$firstName` property of that object, while the other objects from the same class are unchanged.

**Static methods** and **static properties** belong to the class itself, so such methods cannot use `$this` and both such properties and methods are referred to using the class name followed by a double colon (the **scope resolution operator**) and then the property or method name. For example, `User::getNextId()`, not `$userObject->getNextId()`.

Additionally, classes may declare **constants**. These are immutable values accessed with the scope resolution operator (`ClassName::CONSTANT`).

Inside the class, we can use the `self` keyword followed by the scope resolution operator to access static methods, static properties, and constants.

PSR-1 specifies that class constants MUST be declared in all upper case with underscore separators, class methods MUST be declared in camel case, and class properties can be declared in any naming convention as long as it is consistently applied "within a reasonable scope."

## Constructors & Destructors

When you create an object, PHP calls its **constructor**—a special method named `__construct()`.  Constructors often initialize properties or set up resources.  If your class extends a parent class and you need the parent constructor’s logic, you must call it explicitly via `parent::__construct()`.  Constructors can accept typed parameters with default values.  Complementing constructors are **destructors** (`__destruct()`).  They run when the last reference to an object is destroyed or at script termination.  Use destructors to close file handles, release database connections or perform other cleanup.  Parent destructors are not called automatically, so call `parent::__destruct()` if needed.

The book notes that while it is a deprecated notation, a function with the same name as a class also functions as a constructor. As of PHP 8.0, this is no longer the case - the only way to declare a constructor is by naming it `__construct()` and a method named the same as the class is just a method named the same as the class.

Let's create a constructor for our User class:

```php
class User
{
    public const string ADMIN = 'admin';
    public const string USER = 'user';

    private int $id;
    protected string $firstName;
    protected string $userType = self::USER;

    private static int $nextId = 0;

    public function __construct(string? $firstName, string $userType = self::USER)
    {
        $this->id = self:getNextId();
        $this->firstName = $firstName;
        $this->userType = $userType;
    }
    
    public function getId(): int
    {
        return $this->id;
    }

    public function setFirstName(string $firstName): void
    {
        $this->firstName = $firstName;
    }

    public static function getNextId(): int
    {
        return self::nextId++;
    }
}
```
