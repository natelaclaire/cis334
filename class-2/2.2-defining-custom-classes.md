---
layout: default
title: 2.2 Defining Custom Classes
nav_order: 3
---

# 2.2 Defining Custom Classes (pages 573-587)

## A Simple Class Definition

In PHP, you define a class with the `class` keyword:

```php
class User
{

}
```

A class may be declared in any PHP file, although we'll see that to improve the maintainability of our code, we often define each class in its own file, with the filename matching the class name plus `.php`.

PHP class names are case‑insensitive, but remember that filenames on many platforms are case-sensitive, so given what i just shared, it is common to treat class names as if they were case-sensitive. PHP class names must start with a letter or underscore, followed by any number of letters, numbers, or underscores. They cannot be [reserved words](https://www.php.net/manual/en/reserved.php).

Although not required by the language itself, the [PHP Framework Interop Group](https://www.php-fig.org/)'s [PSR-1: Basic Coding Standard](https://www.php-fig.org/psr/psr-1/) requires that class names be declared in **StudlyCaps** (first letter of each word capital, including the first word).

A class may contain **constants**, **properties** and **methods**, which are together known as **class members**. While the book makes a distinction between the terms for these members on the class vs. an object on page 573, this distinction isn't very common. Properties are sometimes referred to as fields and methods are sometimes referred to as functions.

---

## Defining Class Members

In PHP 8.3, we can now define all class members using a visibility modifier and a type (or return type for methods). Let's look at an example:

```php
class User
{
    public const string ADMIN = 'admin';
    public const string USER = 'user';

    private int $id;
    protected string $firstName;
    protected string $userType = self::USER;

    private static int $nextId = 0;
    
    public function getId(): int
    {
        return $this->id;
    }

    public function setFirstName(string $firstName): void
    {
        $this->firstName = $firstName;
    }

    public static function getNextId(): int
    {
        return self::$nextId++;
    }
}
```

In PHP you control access using **visibility modifiers**, sometimes called **access specifiers**: `public` members are accessible from anywhere; `protected` members are accessible within the class and its subclasses (part of inheritance, which we'll get to); and `private` members are accessible only within the class that defines them. If you don’t specify a visibility for a property, method, or constant, it is public by default. As of 8.4, PHP now allows **Asymmetric Property Visibility**, meaning that we can define different access modifiers for reading (get) vs. writing (set).

Visibility modifiers are related to **information hiding** and **encapsulation**, allowing the class to control who has what access to data.

Most methods operate on an object instance and use `$this` to refer to the current object. Keep in mind that, in this example, there could be several objects instantiated from the User class. When `$userObject->setFirstName('Bob')` is called, for example, the name "Bob" is stored in the `$firstName` property of that object, while the other objects from the same class are unchanged.

**Static methods** and **static properties** belong to the class itself, so such methods cannot use `$this` and both such properties and methods are referred to using the class name followed by a double colon (the **scope resolution operator**) and then the property or method name. For example, `User::getNextId()` or `User::$nextId`, not `$userObject->getNextId()` or `$userObject->nextId`, respectively. Note that we include a dollar sign before the static property name, which is different from how an object property is referenced, even though declaration for both types of properties includes a dollar sign before the name.

Additionally, classes may declare **constants**. These are immutable values tied to the class not an object and are therefore also accessed with the scope resolution operator (`ClassName::CONSTANT`). A constant's value is defined at the time of declaration. Just as with global constant, class constants don't start with a dollar sign.

Inside the class, we can use the `self` keyword followed by the scope resolution operator to access static methods, static properties, and constants.

PSR-1 specifies that class constants MUST be declared in all upper case with underscore separators, class methods MUST be declared in camel case, and class properties can be declared in any naming convention as long as it is consistently applied "within a reasonable scope."

As of PHP 8.1, we have a new object property type: **readonly properties** can be set exactly once. Once they have a value, they cannot be modified. Unlike constants, they are object properties (so they can be different for each object of a class) and are therefore accessed using the member selection notation (`->`). Additionally, the value can be provided in the constructor or at some other point - unlike a constant it is not included in the declaration. For example:

```php
<?php

class Test {
   public readonly string $prop;

   public function __construct(string $prop) {
       // Legal initialization.
       $this->prop = $prop;
   }
}

$test = new Test("foobar");
// Legal read.
var_dump($test->prop); // string(6) "foobar"

// Illegal reassignment. It does not matter that the assigned value is the same.
$test->prop = "foobar";
// Error: Cannot modify readonly property Test::$prop
?>
```

Note that readonly properties must be typed. Also, until PHP 8.4 readonly properties could only be modified from within the same class, meaning that even if defined as public, they were implicitly private-set. As of 8.4, they are implicitly protected(set), meaning that they can be set from a child class or from the same class but not from other classes and we can now override this explicitly using Asymmetric Property Visibility.

## Constructors & Destructors

When you create an object, PHP calls its **constructor**—a special method named `__construct()`.  Constructors often initialize properties or set up resources.  If your class extends a parent class and you need the parent constructor’s logic, you must call it explicitly via `parent::__construct()`.  Constructors can accept typed parameters with default values.  Complementing constructors are **destructors** (`__destruct()`).  They run when the last reference to an object is destroyed or at script termination.  Use destructors to close file handles, release database connections or perform other cleanup.  Parent destructors are not called automatically, so call `parent::__destruct()` if needed.

The book notes that while it is a deprecated notation, a function with the same name as a class also functions as a constructor. As of PHP 8.0, this is no longer the case - the only way to declare a constructor is by naming it `__construct()` and a method named the same as the class is just a method named the same as the class.

Let's create a constructor for our User class:

```php
class User
{
    public const string ADMIN = 'admin';
    public const string USER = 'user';

    private int $id;
    protected ?string $firstName;
    protected string $userType;

    private static int $nextId = 0;

    public function __construct(?string $firstName = null, string $userType = self::USER)
    {
        $this->id = self::getNextId();
        $this->firstName = $firstName;
        $this->userType = $userType;
    }
    
    public function getId(): int
    {
        return $this->id;
    }

    public function getUserType(): string
    {
        return $this->userType;
    }

    public function setFirstName(string $firstName): void
    {
        $this->firstName = $firstName;
    }

    public static function getNextId(): int
    {
        return self::nextId++;
    }
}

$user1 = new User('Alice');
$user2 = new User('Liz', User::ADMIN);
```

---

## `__toString`

`__construct` and `__destruct` are examples of magic methods, special functions that begin with a double underscore and let you customize how objects behave in specific situations. We'll discuss more of these next week, but this week I'd like to talk about one more: one of the most useful magic methods — `__toString`.

This defines what happens when you try to use an object as a string. By default, if you try to use an object where a string would be expected (such as in an echo statement), it causes a fatal error: `Fatal error: Uncaught Error: Object of class [class name] could not be converted to string`.

```php
error_reporting(E_ALL);
ini_set('display_errors', '1');

class User {
    //... existing class

    public function __toString() {
        return "{$this->userType} ID #{$this->id}: " . $this->firstName;
    }
}

echo $user1 . '<br>';
echo $user2 . '<br>';
```

Now you get a readable string instead of a fatal error.


## Using the `instanceof` Keyword

The `instanceof` keyword in PHP is used to check if an object is an instance of a specific class or implements a specific interface. This is especially useful when working with inheritance or polymorphism.

### Example

```php
class Animal {}
class Dog extends Animal {}

$a = new Animal();
$d = new Dog();

var_dump($a instanceof Animal); // true
var_dump($d instanceof Animal); // true (Dog is a subclass of Animal)
var_dump($d instanceof Dog);    // true
var_dump($a instanceof Dog);    // false
```

You can also use `instanceof` to check if an object implements an interface:

```php
interface Speakable {}
class Cat implements Speakable {}
$c = new Cat();
var_dump($c instanceof Speakable); // true
```

This keyword is case-insensitive and helps ensure your code works with the correct types of objects, especially when using polymorphism or type-hinting in methods.
