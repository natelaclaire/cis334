---
layout: default
title: 2.2 Defining Custom Classes
nav_order: 3
---

# 2.2 Inheritance & Polymorphism

### Slide 8 – Inheritance & Polymorphism

“PHP supports **single inheritance**: a class may extend one parent class to reuse and specialize its behaviour.  Subclasses inherit all **public** and **protected** properties and methods.  Private members are not inherited, and visibility can be relaxed (e.g., changing a protected method to public) but cannot be restricted.  You can build multi‑level hierarchies (child of a child), but PHP does not support multiple inheritance.  **Polymorphism** means that objects of different classes can be treated uniformly if they share a common interface or base class.  You override a method in a child class to provide specialized behaviour, and at runtime PHP calls the appropriate version.  This allows functions to accept any object implementing a given interface and still behave correctly.”

---

### Slide 9 – Interfaces & Abstract Classes

“An **interface** defines a set of method signatures and constants but provides no implementation.  All interface methods are implicitly public, and any class that *implements* an interface must implement **all** of its methods with compatible parameter names.  Interfaces allow you to define a contract and write code against that contract rather than against concrete classes.  PHP also provides **abstract classes**.  An abstract class may contain both abstract methods (which must be implemented by child classes) and concrete methods.  You cannot instantiate an abstract class directly, but you can provide shared behaviour that is inherited by subclasses.  The table compares the two: both interfaces and abstract classes are not instantiable; interfaces only declare public methods and constants, while abstract classes can include concrete methods and properties; classes can implement multiple interfaces but can extend only one abstract class.”

---

### Slide 10 – Traits

“PHP’s **traits** solve the problem of code reuse in a single‑inheritance language.  A trait is like a partial class: you define methods and properties in a trait, then `use` it inside one or more classes.  Traits cannot be instantiated directly; they must be imported into classes.  When a class uses multiple traits or inherits from a parent, PHP resolves conflicts according to a precedence order: methods defined in the class override trait methods, and trait methods override inherited methods.  Use traits judiciously to share functionality such as logging or timestamping across unrelated classes without creating deep inheritance hierarchies.”

---

### Slide 11 – Static, Final & Scope

The **final** keyword prevents modification: a `final` class cannot be extended, and a `final` method cannot be overridden in subclasses.  Use `final` to lock down critical behaviour.

---

### Slide 12 – Magic Methods

“PHP reserves method names beginning with a double underscore (`__`) for **magic methods**.  These special methods let you customize how objects behave in specific situations.  The constructor (`__construct`) and the cloning method (`__clone`) run when an object is created and cloned.  Magic methods like `__serialize` and `__unserialize` handle object serialization, while `__debugInfo` customizes debug output.  Property and method overloading methods (`__get`, `__set`, `__isset`, `__unset`, `__call`, `__callStatic`) allow you to intercept access to undefined or inaccessible members.  `__toString` lets an object be converted to a string, and `__invoke` makes an object callable like a function.  Except for the constructor, destructor and clone methods, magic methods must be declared **public**.  Use these methods sparingly and consistently to implement advanced behaviours such as proxies or dynamic properties.”

---

### Slide 13 – What’s New in PHP 8.3

“PHP 8.3 introduces several improvements relevant to OOP.  **Typed class constants** now allow you to declare the expected type of a class constant, adding another layer of type safety.  **Dynamic constant fetch** lets you access class constants dynamically using variable names (e.g., `C::${'A'}`).  The new `#[Override]` attribute enforces that a method indeed overrides a parent method; if it doesn’t, PHP will throw an error, helping you avoid subtle bugs.  Finally, **deep cloning of readonly properties** ensures that when you clone an object with a readonly property containing another object, the inner object is also cloned rather than shared.  These features enhance type safety and developer confidence when writing object‑oriented code.”

