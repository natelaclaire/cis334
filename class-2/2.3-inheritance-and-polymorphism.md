---
layout: default
title: 2.3 Inheritance & Polymorphism
nav_order: 4
---

# 2.3 Inheritance & Polymorphism

Got it! Let’s expand your lecture on **inheritance and polymorphism in PHP**, grounding the concepts with a relatable `User` / `Admin` example.

***

# Lecture: Inheritance and Polymorphism in PHP

## 1. Introduction to Inheritance

- **Definition:** Inheritance is a fundamental concept in object-oriented programming (OOP) where one class (called the child or subclass) can acquire the properties and methods of another class (the parent or superclass).
- **Why it matters:** This promotes code reuse, reduces redundancy, and creates a clear, hierarchical structure in your code.

**Example: A `User` class**

```php
<?php
class User {
    protected $username;
    protected $email;

    public function __construct($username, $email) {
        $this->username = $username;
        $this->email = $email;
    }

    public function getUsername() {
        return $this->username;
    }

    public function getEmail() {
        return $this->email;
    }

    public function login() {
        return "{$this->username} has logged in.";
    }
}
?>
```

- Here, `User` defines some shared properties (`username`, `email`) and common behavior (`login()`).

***

## 2. Extending Classes with `extends`

- In PHP, you create an inheritance relationship using the `extends` keyword.
- A subclass not only inherits methods and properties from its parent but can also introduce its own specialized behavior.
- PHP supports **single inheritance**: a class may extend one class to reuse and specialize its behavior. You can build multi‑level hierarchies (child of a child), but PHP does not support multiple inheritance.
- Subclasses inherit all **public** and **protected** properties and methods.  Private members are not inherited, and visibility can be relaxed (e.g., changing a protected method to public) but cannot be restricted.
- **Impact on inheritance:**  
  - `protected` ensures subclasses can work with parent properties/methods without exposing them to the outside world.  
  - `private` keeps critical details locked within the parent, preventing accidental misuse.

**Example: An `Admin` subclass**

```php
<?php
class User {
    public $username;       // Accessible anywhere
    protected $email;       // Accessible only in User and its subclasses
    private $password;      // Accessible only inside User

    public function __construct($username, $email, $password) {
        $this->username = $username;
        $this->email = $email;
        $this->password = $password;
    }

    protected function getEmail() {
        return $this->email;
    }

    private function getPassword() {
        return $this->password;
    }
}

class Admin extends User {
    private $level;

    public function __construct($username, $email, $password, $level) {
        // Reuse parent constructor to initialize inherited properties
        parent::__construct($username, $email, $password);
        $this->level = $level;
    }

    public function getLevel() {
        return $this->level;
    }

    // A new method unique to Admin
    public function deleteUser(User $user) {
        return "{$this->username} deleted user {$user->getUsername()}";
    }

    public function showEmail() {
        // ✅ Allowed, because $email is protected
        return $this->getEmail();
    }

    public function showPassword() {
        // ❌ Not allowed, because $password and getPassword() are private
        return $this->getPassword();
        //return "Cannot access password directly!";
    }
}
?>
```

- The `Admin` class **inherits** everything from `User` but **adds**:
  - A `$level` property
  - A `getLevel()` method
  - A `deleteUser()` method specific to administrators

***

## 3. Method Overriding (A Form of Polymorphism)

- **Polymorphism** allows objects of different classes related by inheritance to respond differently to the same method call.
- A child class can **override** a parent’s method by redefining it.

**Example: Overriding `login()`**

```php
<?php
class Admin extends User {
    private $level;

    public function __construct($username, $email, $level) {
        parent::__construct($username, $email);
        $this->level = $level;
    }

    public function login() {
        // Override parent login, customize for admins
        return "Admin {$this->username} (level {$this->level}) logged in with elevated privileges.";
    }
}
?>
```

- If we instantiate both `User` and `Admin` objects:

```php
$user = new User("jdoe", "jdoe@example.com");
$admin = new Admin("admin1", "admin@example.com", 5);

echo $user->login();  
// Output: jdoe has logged in.

echo $admin->login(); 
// Output: Admin admin1 (level 5) logged in with elevated privileges.
```

This demonstrates **polymorphic behavior**: the method name is the same, but the behavior changes depending on the object type.

***

## 4. Abstract Classes

- An **abstract class** cannot be instantiated.  
- It can include fully defined methods **and** abstract methods (methods declared without implementation).  
- Subclasses **must** implement any abstract methods.
- Abstract methods can be public or protected.

**Example:**
```php
abstract class User {
    protected $username;
    protected $email;

    public function __construct($username, $email) {
        $this->username = $username;
        $this->email = $email;
    }

    abstract public function login(); // Must be implemented by subclasses

    public function getEmail() {
        return $this->email;
    }
}

class Admin extends User {
    public function login() {
        return "Admin {$this->username} logged in.";
    }
}

class Member extends User {
    public function login() {
        return "Member {$this->username} logged in.";
    }
}
```

- Here, both `Admin` and `Member` provide their own versions of `login()`.  
- `User` serves as a **blueprint**, ensuring all user types support `login()`.

***

## 5. Interfaces

- An **interface** defines a contract: a list of methods that implementing classes must provide.  
- Unlike abstract classes, interfaces:
  - Cannot contain property definitions.  
  - Cannot include method implementations (all methods are abstract by default).  
  - Support **multiple inheritance** (a class can implement multiple interfaces).
  - All interface methods are implicitly public.

**Example:**
```php
interface Loggable {
    public function login();
    public function logout();
}

class User implements Loggable {
    protected $username;

    public function __construct($username) {
        $this->username = $username;
    }

    public function login() {
        return "{$this->username} logged in via interface.";
    }

    public function logout() {
        return "{$this->username} logged out.";
    }
}
```

- Any class that implements `Loggable` **must** provide `login()` and `logout()` methods.  
- This is often used to enforce consistency across unrelated classes.

***

## 6. Traits

- **Traits** allow you to "mix in" reusable sets of methods and properties into multiple classes, avoiding duplication.  
- Traits are useful when a behavior doesn’t fit neatly into the inheritance hierarchy.
- A trait is like a partial class: you define methods and properties in a trait, then `use` it inside one or more classes.
- Traits cannot be instantiated directly; they must be imported into classes.
- When a class uses multiple traits or inherits from a parent, PHP resolves conflicts according to a precedence order: methods defined in the class override trait methods, and trait methods override inherited methods.

**Example:**
```php
trait Timestampable {
    private $createdAt;

    public function setCreatedAt($time) {
        $this->createdAt = $time;
    }

    public function getCreatedAt() {
        return $this->createdAt;
    }
}

class User {
    use Timestampable;

    protected $username;
    public function __construct($username) {
        $this->username = $username;
        $this->setCreatedAt(date("Y-m-d H:i:s"));
    }
}

$user = new User("jdoe");
echo $user->getCreatedAt();
```

- Here, `User` gains timestamp functionality without requiring inheritance.  
- Multiple unrelated classes (`Post`, `Comment`, `Admin`) could also `use` `Timestampable`.

***

## 7. The `final` Keyword

- `final` can be applied to **classes** or **methods**.
  - A **final class** cannot be extended.  
  - A **final method** cannot be overridden.

**Example:**
```php
final class SuperAdmin extends User {
    public function login() {
        return "SuperAdmin {$this->username} logged in with root privileges.";
    }
}

// ❌ Trying to extend SuperAdmin would cause an error
// class DeveloperAdmin extends SuperAdmin {}

class Admin extends User {
    final public function resetPassword() {
        return "Password reset is enforced by Admin.";
    }
}

// ❌ This would cause an error if attempted in a subclass of Admin
// public function resetPassword() { ... }
```

- Use `final` to **lock down security-sensitive behavior** or **prevent misuse** in a class hierarchy.  

***

## 8. #[\Override] Attribute

PHP 8 introduced a new feature called **attributes** that provide structured, machine-readable metadata for classes, methods, functions, parameters, properties, and constants. We're not going to get into the specifics of attributes, but PHP 8.3 introduced a new attribute that is very powerful in polymorphism and so we'll discuss just that one. The **#[\Override] attribute** allows us to indicate to PHP that a method is meant to override a parent class method. Using this attribute helps to reduce typos and other mistakes because if you use the attribute on a method that doesn't override a parent class method, PHP will display a compile-time error, letting you know that something is wrong.

For example, with our `Admin` class, we could add the attribute to the `login()` methods:

```php
class Admin extends User {
    private $level;

    public function __construct($username, $email, $level) {
        parent::__construct($username, $email);
        $this->level = $level;
    }

    #[\Override]
    public function login() {
        // Override parent login, customize for admins
        return "Admin {$this->username} (level {$this->level}) logged in with elevated privileges.";
    }
}
```

If everything is correct, you won't see a change, but what if you misspelled `login()` as `llogin()`? You might not notice the typo, but PHP will:

```
Fatal error: Admin::llogin() has #[\Override] attribute, but no matching parent method exists
```

Without that, if you called the `login()` method on an `Admin` object, the `login()` method in the `User` class would run, which isn't what you intended and could lead to issues that are incredibly hard to track down.

***

## 9. Putting It All Together: Example Scenario

Consider a system with multiple user roles:

```php
interface Auditable {
    public function getAuditLog();
}

trait Notifiable {
    public function notify($message) {
        return "Notification: {$message}";
    }
}

abstract class User {
    protected $username;
    public function __construct($username) { $this->username = $username; }
    abstract public function login();
}

class Admin extends User implements Auditable {
    use Notifiable;

    #[\Override]
    public function login() {
        return "Admin {$this->username} logged in.";
    }

    public function getAuditLog() {
        return "Audit log for Admin {$this->username}.";
    }
}
```

- `User` ensures all subclasses define `login()`.  
- `Admin`:
  - Implements `Auditable` → contract enforces audit logging.  
  - Uses `Notifiable` → gains the ability to send notifications without duplicating code.  

This illustrates the synergy of **abstract classes, interfaces, traits, access control, and `final`**.

***

## 10. Practical Benefits

- **Code Reuse:** Common functionality (`username`, `email`, `login()`) is defined once in `User`.
- **Extensibility:** Specialized classes like `Admin`, `Moderator`, or `Subscriber` can extend `User` with minimal duplication.
- **Flexibility:** Other functions can operate on a generic `User` type, and thanks to polymorphism, the correct method is always called depending on the object.

For example:

```php
function performLogin(User $user) {
    echo $user->login();
}

performLogin($user);   // Works for regular users
performLogin($admin);  // Works for admins too
```

***

## 11. Summary

- **Inheritance:** Allows one class to build on another, promoting reuse and structure.
- **Polymorphism:** Enables different object types to provide different implementations of the same interface or method call.
- **Admin / User Example:**  
  - `User`: Base functionality (shared attributes and actions).  
  - `Admin`: Extends `User`, adds specialized functionality, and overrides certain methods.
- **Access modifiers:** Control exposure across inheritance chains.  
- **Abstract classes:** Blueprints for subclasses, allowing shared code plus required methods.  
- **Interfaces:** Define contracts that classes must fulfill, enabling polymorphism across unrelated classes.  
- **Traits:** Provide reusable chunks of behavior outside of strict class hierarchies.  
- **`final`:** Locks down inheritance or overriding where necessary.  

Together, these tools give you the flexibility to design robust, maintainable, and secure object-oriented applications in PHP.
