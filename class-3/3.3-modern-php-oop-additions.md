---
layout: default
title: 3.3 Modern PHP OOP Features
nav_order: 4
---

# 3.3 Modern PHP OOP Features

In this lesson, we’re going to explore some *modern PHP features* that make your code cleaner, safer, and more flexible.

We’ll cover:

* Dynamic constant fetch
* Constructor property promotion
* Nullsafe operators
* And named arguments

---

## Dynamic Constant Fetch

Let’s start with **constants**.

In PHP, you normally access a class constant like this:

```php
class UserRole {
    public const ADMIN = 'admin';
    public const EDITOR = 'editor';
    public const VIEWER = 'viewer';
}

echo UserRole::ADMIN; // admin
```

But what if we want to choose the constant *dynamically*—say, based on user input?

That’s where **dynamic constant fetch** comes in.

```php
$roleName = 'EDITOR';
echo UserRole::{$roleName}; // editor
```

Here, we’re using curly braces to fetch a constant by variable name.

---

## Constructor Property Promotion

Now let’s imagine a `User` class that stores a name and role. Normally, we’d have to write properties, a constructor, and assignments:

```php
class User {
    private string $name;
    private string $role;

    public function __construct(string $name, string $role) {
        $this->name = $name;
        $this->role = $role;
    }
}
```

That’s a lot of boilerplate.

With **constructor property promotion**, we can shorten this dramatically:

```php
class User {
    public function __construct(
        private string $name,
        private string $role
    ) {}
}
```

When we specify the access modifier and data type in the constructor signature, PHP automatically creates the properties and assigns them, combining three separate actions into one. Much cleaner!

---

## Nullsafe Methods and Properties

Next, let’s say each user *might* have a profile, but not always. Accessing something like `$user->profile->bio` could cause an error if `profile` is null.

Traditionally, we’d have to check with an `if` statement or perhaps a ternary operator:

```php
if (isset($user->profile)) {
    $bio = $user->profile->bio;
}
// or
$bio = $user->profile ? $user->profile->bio : null;
```

But with the **nullsafe operator**, we can write this instead:

```php
$bio = $user->profile?->bio;
// or
$bio = $user->getProfile()?->bio;
```

If `profile` or the return value of `getProfile()` is null, PHP just returns null instead of throwing an error. We can also use the same operator to call methods, for example:

```php
$emailLink = $user->profile?->getEmailLink();
// or
$emailLink = $user->getProfile()?->getEmailLink();
```

---

## Named Arguments

Finally, let’s add a method for sending messages. Suppose our method looks like this:

```php
class User {
    public function sendMessage(
        string $recipient,
        string $subject,
        string $body,
        bool $urgent = false
    ) {
        echo "To: $recipient | Subject: $subject | Urgent: " 
            . ($urgent ? "YES" : "NO") . "\n";
        echo $body . "\n";
    }
}
```

Normally, when calling it, we’d have to remember the exact order of arguments. But, as we discussed in CIS 333, PHP now supports **named arguments** for functions. As you might imagine, this applies to class methods as well, so we can call it like this instead:

```php
$user->sendMessage(
    recipient: "bob@example.com",
    body: "Don’t forget our meeting tomorrow!",
    subject: "Meeting Reminder",
    urgent: true
);
```

Remember that we can specify named arguments in *any order*. This makes code more readable and less error-prone.

---

## Closing Thoughts

So, to recap:

* **Dynamic constant fetch** lets you choose constants by variable name.
* **Constructor property promotion** removes boilerplate in class constructors.
* **Nullsafe operators** let you safely access properties or methods that might be null.
* **Named arguments** give you more flexibility and readability when calling methods.

These modern features make PHP code cleaner, safer, and easier to maintain.

Thanks for watching, and I’ll see you in the next lesson!
