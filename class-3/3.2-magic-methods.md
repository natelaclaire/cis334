---
layout: default
title: 3.2 Magic Methods in PHP
nav_order: 3
---

# 3.2 Magic Methods in PHP

Hi everyone! In this video, we’re going to explore some of PHP’s *magic methods*.

Magic methods are special functions that begin with a double underscore, like `__construct`, `__destruct`, `__toString`, and `__clone`, which we've discussed already. These let you customize how objects behave in specific situations. In this video, we’ll look at some other powerful magic methods.

---

## `__serialize` and `__unserialize`

Next up: `__serialize` and `__unserialize`.

Serialization involves converting an object into a storable format—like for saving it in a file or database. When an object needs to be serialized, PHP calls `__serialize`, which must return an associative array that PHP will then convert into a string using a specific format. When you need to take the serialized value and restore it to an object, PHP calls `__unserialize`, which takes an associative array that has been constructed from the serialized string and must populate the object properties from that array.

```php
class Product {
    private $name;
    private $price;

    public function __construct($name, $price) {
        $this->name = $name;
        $this->price = $price;
    }

    public function __serialize(): array {
        return ['n' => $this->name, 'p' => $this->price];
    }

    public function __unserialize(array $data): void {
        $this->name = $data['n'];
        $this->price = $data['p'];
    }
}

$product = new Product('My First Book', 15.96);

$serialized = serialize($product);

echo $serialized . '<br>';

$newProduct = unserialize($serialized);

var_dump($newProduct);
```

This way, *you* control exactly what gets saved and restored. We'll see the real power behind these functions when we discuss state management in a few weeks.

---

## `__debugInfo`

Now, what about debugging?

Normally, when you use `var_dump()` on an object, PHP shows everything. But sometimes that’s too much—or even a security risk. That’s where `__debugInfo` comes in.

```php
class Account {
    private $username;
    private $password;

    public function __construct($username, $password) {
        $this->username = $username;
        $this->password = $password;
    }

    public function __debugInfo() {
        return ['username' => $this->username, 'password' => '****'];
    }
}

$account = new Account('user', 'pass');

var_dump($account);
```

Here, the real password is hidden, but you still get useful debug info.

---

## Property and Method Overloading

Next, let’s talk about *overloading*.

These methods handle situations where you access properties or methods that don’t exist.

* `__get($name)` runs when you read an undefined property.
* `__set($name, $value)` runs when you write to one.
* `__isset` and `__unset` handle `isset()` and `unset()`.
* `__call($name, $arguments)` handles undefined *instance* methods.
* And `__callStatic` does the same for static methods.

Example:

```php
class DataStore {
    private $data = [];

    public function __get($name) {
        return $this->data[$name] ?? null;
    }

    public function __set($name, $value) {
        $this->data[$name] = $value;
    }
}
```

This lets you simulate *dynamic properties*—though you should use it carefully, since it can make debugging tricky.

---

## `__invoke`

Finally, `__invoke`.

This method makes an object *callable*, like a function.

```php
class Adder {
    public function __invoke($a, $b) {
        return $a + $b;
    }
}
```

Now, `$sum = new Adder();` can be used like `$sum(3, 4);`. Pretty neat!

---

## Closing Thoughts

To wrap things up:

* Magic methods are powerful, but they should be used sparingly.
* Except for the constructor, destructor, and `__clone` methods, they must be declared **public**.
* Use them when they make your code cleaner or more expressive, but don’t overdo it—because too much “magic” can make your code confusing.

Thanks for watching, and I’ll see you in the next video!
