---
layout: default
title: 3.1 Cloning Objects in PHP
nav_order: 2
---

# 3.1 Cloning Objects in PHP

Hi everyone! In this lesson, we’re going to explore how to *clone* objects in PHP using the `clone` keyword.

Different from a scalar or array variable, when you assign one object variable to another, both variables actually point to the *same object*. Let’s take a closer look.

First, though, let's remind ourselves how scalar and array variables work:

```php
$number1 = 1;
$number2 = $number1; // the value of $number1 is copied into $number2
$number2 = 2;

// $number1 is unchanged
echo 'Number 1: ' . $number1 . '<br>';
echo 'Number 2: ' . $number2 . '<br>';

$array1 = [1, 2, 3];
$array2 = $array1; // the elements in $array1 get copied into $array2
$array2[0] = 7;

// $array1 is unchanged
echo 'Array 1: '.print_r($array1, true) . '<br>';
echo 'Array 2: '.print_r($array2, true) . '<br>';
```

---

## Assignment vs. Cloning

Now consider this example:

```php
class User {
    public $name;
}

$user1 = new User();
$user1->name = "Alice";

$user2 = $user1;   // just assignment
$user2->name = "Bob";

echo $user1->name; // Bob
```

Notice what happened? Even though we changed `$user2`, `$user1` changed too. That’s because both `$user1` and `$user2` point to the same object in memory.

If we really want a *separate copy*, we need to use the `clone` keyword.

---

## Using `clone`

Here’s the same example, but with cloning:

```php
$user1 = new User();
$user1->name = "Alice";

$user2 = clone $user1;   // clone makes a copy
$user2->name = "Bob";

echo $user1->name; // Alice
echo $user2->name; // Bob
```

This time, `$user1` keeps its own value, and `$user2` is independent.

---

## Shallow vs. Deep Copies

But there’s a catch: cloning only creates a **shallow copy**.

That means if your object contains other objects as properties, those *inner objects* are still shared.

```php
class Profile {
    public $bio;
}

class User {
    public $name;
    public $profile;
}

$user1 = new User();
$user1->name = "Alice";
$user1->profile = new Profile();
$user1->profile->bio = "Hello!";

$user2 = clone $user1;
$user2->name = "Bob";
$user2->profile->bio = "Hi there!";

echo $user1->profile->bio; // Hi there!
```

See the problem? Both users ended up sharing the same `Profile` object.

---

## Customizing with `__clone`

To fix this, we can define a `__clone` method. If this exists, it runs automatically after the clone is performed and allows us to make changes to the properties of the clone, including performing a deep copy by using the `clone` keyword on individual properties that are objects. For example:

```php
class User {
    public $name;
    public $profile;

    public function __clone() {
        // Deep copy the profile object
        $this->profile = clone $this->profile;
    }
}
```

Now each user gets their *own* profile.

You could also use the `__clone` method to do things like ensuring that the clone gets its own ID number, since the constructor isn't called on the cloned object, or to ensure that certain sensitive property values aren't included in the cloned object. For example:

```php
class User {
    private static int $nextId = 0;

    public $id;
    public $name;
    public $profile;
    public $password;

    public function __construct()
    {
        $this->id = self::getNextId();
    }

    public function __clone() {
        // Deep copy the profile object
        $this->profile = clone $this->profile;
        $this->id = self::getNextId();
        $this->password = null;
    }

    public static function getNextId(): int
    {
        return self::$nextId++;
    }
}

$user1 = new User();
$user1->name = "Alice";
$user1->password = "SuperSecurePassword1!";
$user1->profile = new Profile();
$user1->profile->bio = "Hello!";

$user2 = clone $user1;
$user2->name = "Bob";
$user2->profile->bio = "Hi there!";

echo $user1->id . ': ' . $user1->name . ' - ' . $user1->profile->bio . ' - ' . $user1->password . '<br>'; // 0: Alice - Hello! - SuperSecurePassword1!
echo $user2->id . ': ' . $user2->name . ' - ' . $user2->profile->bio . ' - ' . $user2->password . '<br>'; // 1: Bob - Hi there! - null
```

---

## Cloning `readonly` Properties

Prior to PHP 8.3, attempting to modify a `readonly` property within `__clone()` or any other method would result in a fatal error. This limitation made deep cloning of objects with nested `readonly` properties challenging, often requiring workarounds. As of PHP 8.3, the `__clone()` magic method is now an exception to the `readonly` rule. `readonly` properties can be assigned a new value or unset within the `__clone()` method, or within methods called from `__clone()`. This allows for the creation of a truly independent clone, where nested `readonly` objects can also be cloned and reinitialized if necessary.

---

## Closing Thoughts

To summarize:

* By default, assigning an object variable only creates a *reference*.
* To get a separate copy, use the `clone` keyword.
* Cloning is shallow, so objects inside your object are still shared.
* Use the `__clone` magic method to make deep copies when you need them and to make other changes to the cloned properties.

That’s it for cloning objects! In the next lesson, we’ll see how this ties into other magic methods for customizing object behavior.
