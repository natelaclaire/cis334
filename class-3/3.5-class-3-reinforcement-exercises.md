
---
layout: default
title: 2.4 Class 2 Reinforcement Exercises
nav_order: 5
---

# 3.6 Class 3 Reinforcement Exercises

Before you begin the Reinforcement Exercises, remember to accept and merge the Pull Request that I've submitted for your weekly assignments repository, just as we did last week.

## Exercise 3-1

1. Using your Codespace, open the `public/exercises/3-1-books.php` file.
2. Inside the `Book` class, add the following constructor, which uses **constructor property promotion** to declare the class properties and assign values:

```php
public function __construct(
    public string $title, 
    public string $author, 
    public Publisher $publisher
) {
}
```

3. Modify the `Publisher` class to also use constructor property promotion.

4. Save the file and open the page in your browser. You should see the following:
   * The Great Gatsby by F. Scott Fitzgerald, published by HarperCollins
   * 1984 by George Orwell, published by Secker & Warburg
   * To Kill a Mockingbird by Harper Lee, published by J.B. Lippincott & Co.
   * The Great Gatsby - Special Edition by F. Scott Fitzgerald, published by HarperCollins

5. Note that because of shallow cloning, the publisher for the first book was changed along with the fourth. Add the following magic method to the `Book` class to perform a deep clone:

```php
public function __clone()
{
    $this->publisher = clone $this->publisher;
}
```

6. Save the file and refresh the page in your browser. You should now see:
   * The Great Gatsby by F. Scott Fitzgerald, published by Scribner
   * 1984 by George Orwell, published by Secker & Warburg
   * To Kill a Mockingbird by Harper Lee, published by J.B. Lippincott & Co.
   * The Great Gatsby - Special Edition by F. Scott Fitzgerald, published by HarperCollins

## Exercise 3-2

In this exercise, you'll explore one way that the `__get()` and `__set()` magic methods can be used to create a dynamic class that can reflect data available in an external system or file.

1. Using your Codespace, open the `public/exercises/3-2-documents.php` file.
2. In the `Document` class, add the following constructor, which takes an array and stores it in the `$data` property:

```php
public function __construct(array $data) {
    $this->data = $data;
}
```

3. Below that, add the following magic methods, which are called by PHP when there is an attempt to modify or read from properties that don't exist. These implementations interact with the `$data` array property returning the matching array element, or `null` if it doesn't exist.

```php
public function __get($name)
{
    return $this->data[$name] ?? null;
}

public function __set($name, $value)
{
    $this->data[$name] = $value;
}
```

4. Complete the `Document` class by adding the following magic methods that are used by PHP when `isset()` or `unset()` are used on a class property that doesn't exist:

```php
public function __isset($name)
{
    return isset($this->data[$name]);
}

public function __unset($name)
{
    unset($this->data[$name]);
}
```

5. The `Documents` class loads a JSON file named `public/exercises/3-2-documents.json` and creates a `Document` object for each element of the array in the JSON file.
6. Open the page in your web browser and confirm that two documents are listed:
    * Books - Author: Your Name - Learn about PHP classes, constructors, property promotion, and namespaces with practical examples.
    * Namespaces - Author: Your Name - Learn about PHP namespaces with practical examples.

## Exercise 3-3

In this exercise, you'll complete a PHP script that displays a chess board and provides rudimentary movement of chess pieces, using OOP. It is not a complete chess game - any gameplay mechanics such as timing and score keeping and turn-based logic are not implemented. Additionally, no work has been done to prevent a player from capturing their own pieces. There are probably other missing parts as well.

1. Using your Codespace, open the `public/exercises/3-3-chess.php` file.
2. Take a look at the `ChessPiece` abstract class. It provides the basic structure for all of the chess piece subclasses, including defining a basic constructor. It also defines an abstract method that all subclasses must override, which will be used to determine if the move being requested is valid. If you are familiar with chess, you know that each individual type of piece has its own valid moves and we're using this as another example of polymorphism. The class also provides a static method that takes a position in standard chess notation (such as "a1") and converts it to a 2-element array containing the row index and column index (0-7 for each).
3. The `Pawn` subclass is complete. It implements a constructor that passes the "P" indicator for the piece type (P = Pawn), and the color (white or black) to the parent constructor. It also defines a `__toString()` method that outputs a Unicode character for the piece, depending on the color. It then overrides the `isValidMove()` method, which takes two spaces and determines if it is valid for a pawn to move from one to the other. This method is called by the `ChessBoard::movePiece()` method to ensure that only valid moves are performed. Note that the first two non-comment lines in the `Pawn::isValidMove()` method use the `ChessPiece::rowColFromPosition()` static method and these same two lines will be needed for each of the other `isValidMove()` methods in the other subclasses. The logic for `Pawn::isValidMove()` is quite a bit more complicated than the same method in the other subclasses and I encourage you to look through it to see if it makes sense to you.
4. Class `Rook` will be quite familiar to you. The `Rook::isValidMove()` method is empty, so you'll need to copy the following and paste it in to complete it:

```php
[$startRow, $startCol] = ChessPiece::rowColFromPosition($start);
[$endRow, $endCol] = ChessPiece::rowColFromPosition($end);

return $startRow === $endRow || $startCol === $endCol;
```

5. The `Knight::isValidMove()` method needs the `$startRow`, `$startCol`, `$endRow`, and `$endCol` variables populated the same way as `Rook` and `Pawn` did, so copy and paste those two lines from `Rook` above into the `Knight::isValidMove()` method.
6. Next, add the following to `Knight::isValidMove()`:

```php
$rowDiff = abs($endRow - $startRow);
$colDiff = abs($endCol - $startCol);

return ($rowDiff === 2 && $colDiff === 1) || ($rowDiff === 1 && $colDiff === 2);
```

7. Repeat that basic process for the `Bishop`, `Queen`, and `King` classes. The `isValidMove()` method needs both calls to `ChessPiece::rowColFromPosition()` and then a line that returns a true or false value. Here are the return statements for each of those three classes:

```php
// Rook::isValidMove()
return abs($endRow - $startRow) === abs($endCol - $startCol);

// Queen::isValidMove()
return $startRow === $endRow || $startCol === $endCol || 
    abs($endRow - $startRow) === abs($endCol - $startCol);

// King::isValidMove()
return abs($endRow - $startRow) <= 1 && abs($endCol - $startCol) <= 1;
```

8. Review the `ChessBoard` class to see the logic. `ChessBoard::movePiece()` determines if a piece is in a particular cell and then gets a reference to the piece's object if there is one. It then calls `isValidMove()` on the object to ensure that the move is valid for that particular type of piece. Finally, it moves the piece to the destination by assigning it to the destination cell and replacing the source cell with `null`.
9. The `setupBoard()` method implements the starting board layout. The `$pieceClasses` array uses the `::class` notation, which we haven't yet discussed, to record a reference to a class in a variable. That way we can use the variable as the name of the class to instantiate. Find the line that reads `$this->board[0][$i] = new $class('white');` to see how that works.
10. We're going to have one object of the `ChessBoard` class at any given time and we'll store a serialized version in a form field, so we need to set up serialization and unserialization. To do that, add the following to the `ChessBoard` class:

```php
public function __serialize(): array
{
    return ['board' => $this->board, 'moveHistory' => $this->moveHistory];
}

public function __unserialize(array $data): void
{
    $this->board = $data['board'];
    $this->moveHistory = $data['moveHistory'];
}
```

11. Browse through the HTML to see how we display the chess board and the form below it. Note that we are storing the serialized `$chessBoard` object in a hidden form field. This is not at all safe and secure - in a production situation we would want to store it in a safe place such as a session variable or database, which we'll explore later this semester.
12. Save the file and then open the page in a browser. Try moving a few pieces and see how it works. In case you aren't familiar with the rules of chess, [I found a relatively simple description of valid piece moves here](https://thechessworld.com/articles/general-information/how-chess-pieces-move/?srsltid=AfmBOopYDzePx7P7RiAj3KIK8ams_bcDRsyZToGam7Prfsce_vpBSQM5).

## Exercise 3-4

In this exercise, you'll practice creating and using namespaces to avoid naming conflicts.

1. Using your Codespace, find the folder `public/exercises/3-4-namespaces`.
2. Inside the folder, create two subfolders:

```
public/exercises/3-4-namespaces
    /Library
    /Store
```

3. In the **Library** folder, create a file named `Book.php` with the following code:

```php
<?php
namespace Library;

class Book {
    public function __construct(public string $title) {}

    public function getInfo(): string {
        return "Library Book: " . $this->title;
    }
}
```

4. In the **Store** folder, create a file named `Book.php` with this code:

```php
<?php
namespace Store;

class Book {
    public function __construct(public string $title, public float $price) {}

    public function getInfo(): string {
        return "Store Book: " . $this->title . " ($" . $this->price . ")";
    }
}
```

5. Now open the `public/exercises/3-4-namespaces/index.php` file. Notice that it:

   * Requires both class files.
   * Imports both classes with `use`.
   * Uses **aliases** to distinguish them.
   * Creates one library book and one store book.
   * Displays their information.

6. Open the page in a Web browser and confirm that the following appears:

```
Library Book: Pride and Prejudice
Store Book: Pride and Prejudice ($12.99)
```

7. Add a **Magazine** class to both the `Library` and `Store` namespaces. Then update `index.php` to demonstrate working with both `Magazine` classes using aliases (add a magazine from each namespace to the output).

8. Refresh the page to ensure that the magazines and books appear as expected.

## Exercise 3-5

In this exercise, you'll get some practice using an autoloader.

1. Using your Codespace, find the folder `public/exercises/3-5-autoloading`.
2. Inside the folder is a `classes` folder and an `index.php` file. Inside the `classes` folder are three files. The `Payable.php` file contains a modified version of our `Payable` interface from reinforcement exercise 2-3. The `Invoice.php` file contains a class that implements the `Payable` interface and the `Vendor.php` file contains a class that is needed for the `Invoice` class. Note that none of these files `require` or `include` any of the others. Also note that none of these files contain a `namespace` statement, which means that the classes are in the global namespace.
3. Open the `index.php` file. At the top is a simple autoloader that will look in the `classes` folder for a file with the same name (plus `.php`) as the class that needs to be loaded and, if the file exists, will require the file. The autoloader includes code that ensures that only non-namespaced classes are loaded by it, and also ensures that the class name is valid. Among other things, this ensures that the autoloader can't be utilized by a hacker to perform directory traversal.
4. Scroll down and you'll see that we've created two invoices, each with a different vendor. The `Vendor` objects are referred to as **anonymous objects** or **inline objects** because they are created inline at the time of use, without storing a reference in a variable.
5. Below that, we've created an array and stored each of the `Invoice` objects in that array.
6. Below that, we have a table that lists all payable objects in the array, calling the `getPayeeName()` and `getPayAmount()` methods required by the `Payable` interface.
7. Load the page in a browser and confirm that you see the two invoices listed.
8. Now, open the `2-3-employees.php` file from last week and copy the `Employee`, `SalariedEmployee`, and `HourlyEmployee` classes into three separate files with matching filenames in the `public/exercises/3-5-autoloading/classes` folder.
9. Add a `getPayeeName()` method to the `Employee` class that returns the employee's name (this can either duplicate the functionality of the `getName()` method or can call the `getName()` method).
10. Return to `index.php` and uncomment lines 42 and 43, which create new `HourlyEmployee` and `SalariedEmployee` objects.
11. Refresh the page in your browser and confirm that the employees show up in the table.
