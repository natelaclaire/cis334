
---
layout: default
title: 2.4 Class 2 Reinforcement Exercises
nav_order: 5
---

# 3.6 Class 3 Reinforcement Exercises

Before you begin the Reinforcement Exercises, remember to accept and merge the Pull Request that I've submitted for your weekly assignments repository, just as we did last week.

## Exercise 3-1

1. Using your Codespace, open the `public/exercises/3-1-books.php` file.
2. Inside the `Book` class, add the following constructor, which uses **constructor property promotion** to declare the class properties and assign values:

```php
public function __construct(
    public string $title, 
    public string $author, 
    public Publisher $publisher
) {
}
```

3. Modify the `Publisher` class to also use constructor property promotion.

4. Save the file and open the page in your browser. You should see the following:
   * The Great Gatsby by F. Scott Fitzgerald, published by HarperCollins
   * 1984 by George Orwell, published by Secker & Warburg
   * To Kill a Mockingbird by Harper Lee, published by J.B. Lippincott & Co.
   * The Great Gatsby - Special Edition by F. Scott Fitzgerald, published by HarperCollins

5. Note that because of shallow cloning, the publisher for the first book was changed along with the fourth. Add the following magic method to the `Book` class to perform a deep clone:

```php
public function __clone()
{
    $this->publisher = clone $this->publisher;
}
```

6. Save the file and refresh the page in your browser. You should now see:
   * The Great Gatsby by F. Scott Fitzgerald, published by Scribner
   * 1984 by George Orwell, published by Secker & Warburg
   * To Kill a Mockingbird by Harper Lee, published by J.B. Lippincott & Co.
   * The Great Gatsby - Special Edition by F. Scott Fitzgerald, published by HarperCollins

## Exercise 3-2

In this exercise, you'll explore one way that the `__get()` and `__set()` magic methods can be used to create a dynamic class that can reflect data available in an external system or file.

1. Using your Codespace, open the `public/exercises/3-2-documents.php` file.
2. In the `Document` class, add the following constructor, which takes an array and stores it in the `$data` property:

```php
public function __construct(array $data) {
    $this->data = $data;
}
```

3. Below that, add the following magic methods, which are called by PHP when there is an attempt to modify or read from properties that don't exist. These implementations interact with the `$data` array property returning the matching array element, or `null` if it doesn't exist.

```php
public function __get($name)
{
    return $this->data[$name] ?? null;
}

public function __set($name, $value)
{
    $this->data[$name] = $value;
}
```

4. Complete the `Document` class by adding the following magic methods that are used by PHP when `isset()` or `unset()` are used on a class property that doesn't exist:

```php
public function __isset($name)
{
    return isset($this->data[$name]);
}

public function __unset($name)
{
    unset($this->data[$name]);
}
```

5. The `Documents` class loads a JSON file named `public/exercises/3-2-documents.json` and creates a `Document` object for each element of the array in the JSON file.
6. Open the page in your web browser and confirm that two documents are listed:
    * Books - Author: Your Name - Learn about PHP classes, constructors, property promotion, and namespaces with practical examples.
    * Namespaces - Author: Your Name - Learn about PHP namespaces with practical examples.

## Exercise 3-3



## Exercise 3-4

In this exercise, you'll practice creating and using namespaces to avoid naming conflicts.

1. Using your Codespace, find the folder `public/exercises/3-4-namespaces`.
2. Inside the folder, create two subfolders:

```
public/exercises/3-4-namespaces
    /Library
    /Store
```

3. In the **Library** folder, create a file named `Book.php` with the following code:

```php
<?php
namespace Library;

class Book {
    public function __construct(public string $title) {}

    public function getInfo(): string {
        return "Library Book: " . $this->title;
    }
}
```

4. In the **Store** folder, create a file named `Book.php` with this code:

```php
<?php
namespace Store;

class Book {
    public function __construct(public string $title, public float $price) {}

    public function getInfo(): string {
        return "Store Book: " . $this->title . " ($" . $this->price . ")";
    }
}
```

5. Now open the `public/exercises/3-4-namespaces/index.php` file. Notice that it:

   * Requires both class files.
   * Imports both classes with `use`.
   * Uses **aliases** to distinguish them.
   * Creates one library book and one store book.
   * Displays their information.

6. Open the page in a Web browser and confirm that the following appears:

```
Library Book: Pride and Prejudice
Store Book: Pride and Prejudice ($12.99)
```

7. Add a **Magazine** class to both the `Library` and `Store` namespaces. Then update `index.php` to demonstrate working with both `Magazine` classes using aliases (add a magazine from each namespace to the output).

8. Refresh the page to ensure that the magazines and books appear as expected.

## Exercise 3-5

In this exercise, you'll get some practice using an autoloader.

1. Using your Codespace, find the folder `public/exercises/3-5-autoloading`.
2. Inside the folder is a `classes` folder and an `index.php` file. Inside the `classes` folder are three files. The `Payable.php` file contains a modified version of our `Payable` interface from reinforcement exercise 2-3. The `Invoice.php` file contains a class that implements the `Payable` interface and the `Vendor.php` file contains a class that is needed for the `Invoice` class. Note that none of these files `require` or `include` any of the others. Also note that none of these files contain a `namespace` statement, which means that the classes are in the global namespace.
3. Open the `index.php` file. At the top is a simple autoloader that will look in the `classes` folder for a file with the same name (plus `.php`) as the class that needs to be loaded and, if the file exists, will require the file. The autoloader includes code that ensures that only non-namespaced classes are loaded by it, and also ensures that the class name is valid. Among other things, this ensures that the autoloader can't be utilized by a hacker to perform directory traversal.
4. Scroll down and you'll see that we've created two invoices, each with a different vendor. The `Vendor` objects are referred to as **anonymous objects** or **inline objects** because they are created inline at the time of use, without storing a reference in a variable.
5. Below that, we've created an array and stored each of the `Invoice` objects in that array.
6. Below that, we have a table that lists all payable objects in the array, calling the `getPayeeName()` and `getPayAmount()` methods required by the `Payable` interface.
7. Load the page in a browser and confirm that you see the two invoices listed.
8. Now, open the `2-3-employees.php` file from last week and copy the `Employee`, `SalariedEmployee`, and `HourlyEmployee` classes into three separate files with matching filenames in the `public/exercises/3-5-autoloading/classes` folder.
9. Add a `getPayeeName()` method to the `Employee` class that returns the employee's name (this can either duplicate the functionality of the `getName()` method or can call the `getName()` method).
10. Return to `index.php` and uncomment lines 42 and 43, which create new `HourlyEmployee` and `SalariedEmployee` objects.
11. Refresh the page in your browser and confirm that the employees show up in the table.
