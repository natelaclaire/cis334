---
layout: default
title: 11.1 Managing State in PHP
nav_order: 1
---

# 11.1 Managing State in PHP

When you click a link or submit a form on a website, your browser sends a request to a web server â€” and the server responds. Thatâ€™s it. Once the response is delivered, the connection is closed and the server forgets everything about you.

Thatâ€™s because **HTTP is a stateless protocol.** Each request is completely independent â€” the server doesnâ€™t automatically remember who you are or what you were doing before.

This stateless nature makes the web simple and efficient, but it creates a challenge for developers: How do we make a userâ€™s experience feel continuous â€” like theyâ€™re â€œlogged in,â€ â€œshopping,â€ or â€œin the middle of a gameâ€?

Thatâ€™s where **state management** comes in.

---

## ğŸ”¹ **1. Hidden Form Fields**

One of the simplest ways to maintain state is with **hidden form fields**, as we did with the first version of the chess app. These are invisible inputs that store data within an HTML form â€” like a username or game score â€” and get resubmitted each time the form is posted.

Itâ€™s a good solution for small, short-lived data, but because the data travels with every form submission, itâ€™s not ideal for sensitive information or larger datasets.

---

## ğŸ”¹ **2. Query Strings**

Another approach is using **query strings**, which attach information to the end of a URL. Youâ€™ve seen them before and we discussed them in CIS 333 â€” the part after the question mark.

PHP can read these values using the `$_GET` array. Just like hidden fields, query strings make state visible to the user â€” which is both an advantage and a security concern.

---

### ğŸ”¹ **3. Cookies**

To persist information beyond a single request, we can use **cookies**. A cookie is a small piece of data stored in the userâ€™s browser, automatically sent back to the server with each request.

You can set a cookie in PHP with the `setcookie()` function, and read it with the `$_COOKIE` array. Cookies are great for remembering user preferences or keeping someone logged in â€” but they live on the client side, so they can be modified or deleted by the user.

---

### ğŸ”¹ **4. Sessions**

To store data securely on the server, we use **sessions**. A session assigns a unique session ID to each visitor, usually stored in a small cookie although it can instead be passed as a query parameter. The actual data â€” like user credentials or cart contents â€” stays on the server.

In PHP, sessions are easy to use:

```php
session_start();
$_SESSION['username'] = 'alex';
```

Sessions are the backbone of most modern PHP applications because they keep data safe and separate from the client.

---

### ğŸ”¹ **5. Modern State Management (2025 and Beyond)**

Since publication of our textbook, web applications have evolved â€” and so have the ways we manage state. Frameworks and APIs often use:

* **JWTs (JSON Web Tokens):** for stateless authentication between frontend and backend.
* **LocalStorage and SessionStorage:** browser-based storage managed by JavaScript, ideal for single-page apps.
* **Redis or Memcached:** in-memory data stores for high-performance session management in scalable PHP applications.

These tools allow PHP to integrate smoothly into modern, cloud-based and API-driven architectures. And yet, we still use hidden form fields, query string parameters, cookies, and sessions extensively.

---

### ğŸ”¹ **Conclusion**

So while HTTP itself forgets every request, PHP gives us plenty of ways to bridge the gap â€” from hidden fields and query strings to cookies and sessions.
Understanding these tools is essential for building dynamic, personalized, and secure web applications.

In the next lesson, weâ€™ll dive deeper into cookies â€” and see how they make user logins, shopping carts, and game progress possible.
