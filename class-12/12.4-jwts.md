---
layout: default
title: 12.4 Using JSON Web Tokens (JWTs) for Authentication in PHP
nav_order: 4
---

# 12.4 Using JSON Web Tokens (JWTs) for Authentication in PHP

## üéì **The Problem with Sessions**

So far, we‚Äôve built secure, session-based authentication ‚Äî and it works great for traditional PHP sites.

But in modern web development ‚Äî especially when you‚Äôre working with **single-page apps** or **mobile clients** ‚Äî sessions can become difficult to scale.

That‚Äôs where **JSON Web Tokens**, or **JWTs**, come in.

In this video, we‚Äôll explore what JWTs are, how they differ from sessions, and how to use them in PHP to create secure, stateless authentication.

---

## üß† **1. What Are JSON Web Tokens (JWTs)?**

A **JSON Web Token** is a self-contained, signed piece of data that proves who a user is.

Instead of storing session data on the server, the server sends the client a token that includes:

* The user‚Äôs ID
* Their role or permissions
* An expiration time
* A digital signature

Each time the client makes a request, it sends that token back.
The server verifies the signature to confirm it hasn‚Äôt been tampered with ‚Äî no session storage required.

---

## üß© **2. JWT Structure**

A JWT has three parts, separated by dots:

```
header.payload.signature
```

Example:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJ1c2VySWQiOjEsInVzZXJuYW1lIjoiYWxleCJ9.
kNqpxx-r5v8hO7K5aR6D6aRZ0hz5TJKk0INxX5sWQoI
```

* **Header:** algorithm and token type
* **Payload:** the user‚Äôs claims (like ID and role)
* **Signature:** verifies that the data hasn‚Äôt been altered

JWTs are **signed**, not encrypted ‚Äî meaning anyone can read the payload, but only the server can verify or create valid tokens.

---

## ‚öôÔ∏è **3. How JWT Authentication Works**

Here‚Äôs the flow:

1. The user logs in with a username and password.
2. PHP verifies their credentials and generates a JWT containing their ID and role.
3. The server sends that token back to the client.
4. The client stores it ‚Äî usually in **localStorage** or **sessionStorage**.
5. On every request, the client includes the token in the HTTP `Authorization` header.
6. The server verifies the token‚Äôs signature and expiration time before granting access.

This creates a fully **stateless** authentication system ‚Äî ideal for APIs and modern front-end frameworks.

---

## üß∞ **4. Installing a JWT Library**

While PHP doesn‚Äôt include JWT handling natively, we can use the excellent open-source package **`firebase/php-jwt`**.

Install it with Composer:

```bash
composer require firebase/php-jwt
```

This library makes it easy to encode, sign, and verify JWTs.

---

## üßæ **5. Creating a Token After Login**

**[Switch to code editor: `12-4-login.php`]**

Let‚Äôs build a login endpoint that returns a JWT instead of starting a session.

```php
<?php
declare(strict_types=1);
require_once 'config.php';
require_once 'database.php';

use Firebase\JWT\JWT;
use Firebase\JWT\Key;

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $username = trim($_POST['username'] ?? '');
    $password = $_POST['password'] ?? '';

    $pdo = Database::getConnection();
    $stmt = $pdo->prepare('SELECT id, password_hash, role FROM users WHERE username = :username');
    $stmt->execute([':username' => $username]);
    $user = $stmt->fetch();

    if ($user && password_verify($password, $user['password_hash'])) {
        $payload = [
            'userId' => (int)$user['id'],
            'username' => $username,
            'role' => $user['role'],
            'exp' => time() + 3600 // expires in 1 hour
        ];

        $jwt = JWT::encode($payload, JWT_SECRET, 'HS256');

        header('Content-Type: application/json');
        echo json_encode(['token' => $jwt]);
        exit;
    }

    http_response_code(401);
    echo json_encode(['error' => 'Invalid credentials']);
}
```

Instead of starting a session, we create a JWT payload and sign it using our secret key.
Then we send it to the client as JSON.

This token now represents the user‚Äôs authenticated state.

---

## üß© **6. Validating the Token**

**[Switch to `12-4-dashboard.php`]**

Here‚Äôs how we verify the token for a protected API endpoint.

```php
<?php
declare(strict_types=1);
require_once 'config.php';
use Firebase\JWT\JWT;
use Firebase\JWT\Key;

$headers = getallheaders();
$authHeader = $headers['Authorization'] ?? '';

if (!str_starts_with($authHeader, 'Bearer ')) {
    http_response_code(401);
    exit('Missing or invalid token');
}

$jwt = substr($authHeader, 7);

try {
    $decoded = JWT::decode($jwt, new Key(JWT_SECRET, 'HS256'));
    echo "Welcome, " . htmlspecialchars($decoded->username);
} catch (Exception $e) {
    http_response_code(401);
    exit('Invalid or expired token');
}
```

This script checks for the `Authorization` header, extracts the token, and verifies it using the same secret key.
If it‚Äôs valid, we can safely use the claims inside the token ‚Äî like username or role ‚Äî without needing any session data.

---

## üíæ **7. Storing and Using Tokens in the Browser**

**[Switch to front-end JavaScript snippet]**

On the client side, we‚Äôll store the JWT after a successful login and include it with future requests.

**`12-4-login.html`**

```javascript
<html>
<head>
  <title>Login</title>
</head>
<body>
<form id="loginForm">
  <input type="text" name="username" placeholder="Username" required>
  <input type="password" name="password" placeholder="Password" required>
  <button type="submit">Login</button>
</form>
<script>
document.getElementById('loginForm').addEventListener('submit', function(event) {
  event.preventDefault();
  fetch('12-4-login.php', {
    method: 'POST',
    body: new FormData(document.querySelector('form'))
  })
    .then(res => res.json())
    .then(data => {
      sessionStorage.setItem('jwt', data.token);
      window.location.href = '12-4-dashboard.html';
    });
});
</script>
</body>
</html>
```

For requests that require authentication:

**`12-4-dashboard.html`**

```javascript
<html>
<head>
  <title>Dashboard</title>
</head>
<body>
<script>
const token = sessionStorage.getItem('jwt');

fetch('12-4-dashboard.php', {
  headers: { 'Authorization': 'Bearer ' + token }
})
  .then(res => res.text())
  .then(console.log);
</script>
</body>
</html>
```

Here we‚Äôre using **`sessionStorage`**, which automatically clears when the browser tab is closed.
If you want persistence between sessions, you could use **`localStorage`** instead ‚Äî just be careful not to store tokens long-term unless absolutely necessary.

---

## üîê **8. Security Best Practices**

* Always use **HTTPS** ‚Äî JWTs are just as sensitive as passwords.
* Set short token lifetimes (1 hour is typical).
* Use a **refresh token** system for long-lived sessions.
* Never store tokens in cookies to avoid CSRF exposure.
* Keep your signing secret safe and never hard-code it in client-side code.

These rules help keep token-based systems just as secure as traditional session systems ‚Äî and often more scalable.

---

## ‚öôÔ∏è **9. Comparing JWTs and PHP Sessions**

| Feature     | JWT                | PHP Session             |
| ----------- | ------------------ | ----------------------- |
| Storage     | Client-side        | Server-side             |
| State       | Stateless          | Stateful                |
| Scalability | Excellent          | Requires shared storage |
| Validation  | Signature          | Session lookup          |
| Best Use    | APIs, SPAs, mobile | Classic PHP apps        |

JWTs shine when you‚Äôre building APIs or connecting to front-end frameworks like React, Vue, or Angular.
But for traditional multi-page PHP applications, sessions are often simpler and safer.

Understanding both approaches lets you choose the right one for each project.

---

## üß† **10. Demo Recap**

**[Switch to browser demonstration]**

Let‚Äôs test this workflow:

1. Submit the login form ‚Äî the server responds with a JWT.
2. Open DevTools ‚Üí Application ‚Üí Storage ‚Üí Session Storage to see it saved.
3. Refresh or navigate ‚Äî the app includes the token automatically in the request header.
4. After an hour, the token expires, and access is denied until you log in again.

That‚Äôs a complete, stateless authentication loop.

---

## ‚úÖ **11. Wrap-Up**

So to summarize:

* **JWTs** allow secure, stateless authentication ‚Äî no sessions needed.
* They‚Äôre ideal for APIs, SPAs, and mobile apps.
* PHP 8.3 works beautifully with modern JWT libraries like `firebase/php-jwt`.
* Tokens must be stored, transmitted, and validated carefully.

By now, you‚Äôve seen how to manage state in multiple ways ‚Äî from cookies and sessions to CSRF protection and now JWTs.
Together, these tools form a complete picture of secure, modern web development in PHP.
