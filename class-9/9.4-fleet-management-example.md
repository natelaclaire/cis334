---
layout: default
title: 9.4 Hydrating Fleet Data into PHP Classes with PDO (Single Shared Connection)
nav_order: 4
---

# 9.4 Hydrating Fleet Data into PHP Classes with PDO (Single Shared Connection)

## 0) Goal for today

We’ll wire PDO once, then model a few key tables as PHP classes. We’ll hydrate rows into objects with camelCase properties using `fetchObject()` or `FETCH_CLASS`, and use **SQL aliases** so snake_case columns fall into the right properties.

Tables we’ll use from your scripts:

* `vehicles` (VIN, license_plate, make/model/year…) 
* `drivers` (first/last/email/phone…) 
* `vendors` (name/type/phone/city/state) 
* `vehicle_assignments` (vehicle_id, driver_id, dates, odometers) 
* `odometer_readings` (vehicle_id, reading_date, odometer, source) 
* `fuel_cards` / `fuel_purchases` (card metadata; per-fill details)  
* `maintenance_types` / `maintenance_records` (service metadata + costs)  

Seed examples include vehicles, drivers, vendors, fuel cards, assignments, odometer readings, fuel purchases, and a maintenance record so your lists show real data.

---

## 1) One connection to rule them all — the `Database` class

We’ll keep a **single** PDO connection in a **static property** so any model can reuse it without reconnecting.

```php
<?php
// src/Database.php
final class Database {
    private static ?PDO $pdo = null;

    public static function get(): PDO {
        if (!self::$pdo) {
            $dsn  = "mysql:host=db;dbname=mydb;charset=utf8mb4";
            $user = "mariadb";
            $pass = "mariadb";
            self::$pdo = new PDO($dsn, $user, $pass, [
                PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                PDO::ATTR_EMULATE_PREPARES   => false,
            ]);
        }
        return self::$pdo;
    }
}
```

If you prefer **SQLite** for demos, just swap DSN to `sqlite:/path/to/fleet.sqlite` and omit user/pass — all the code below still works.

---

## 2) Domain classes (snake_case → camelCase)

Each class uses **camelCase properties**. When we query, we’ll **alias** every column to camelCase so `fetchObject()` can hydrate cleanly.

### Vehicles

Columns: `vehicle_id`, `vin`, `license_plate`, `make`, `model`, `model_year`, etc. 

```php
<?php
// src/Vehicle.php
final class Vehicle {
    public int $vehicleId;
    public string $vin;
    public string $licensePlate;
    public string $make;
    public string $model;
    public int $modelYear;
    public ?string $color = null;
    public ?string $fuelType = null;

    public function label(): string {
        return "{$this->modelYear} {$this->make} {$this->model} ({$this->licensePlate})";
    }

    /** @return Vehicle[] */
    public static function all(): array {
        $sql = "
          SELECT
            vehicle_id      AS vehicleId,
            vin             AS vin,
            license_plate   AS licensePlate,
            make            AS make,
            model           AS model,
            model_year      AS modelYear,
            color           AS color,
            fuel_type       AS fuelType
          FROM vehicles
          ORDER BY model_year DESC, make, model
        ";
        $stmt = Database::get()->query($sql);
        return $stmt->fetchAll(PDO::FETCH_CLASS, self::class);
    }
}
```

### Drivers

Columns: `driver_id`, `first_name`, `last_name`, `email`, `phone`… 

```php
<?php
// src/Driver.php
final class Driver {
    public int $driverId;
    public string $firstName;
    public string $lastName;
    public ?string $email = null;
    public ?string $phone = null;

    public function fullName(): string {
        return "{$this->firstName} {$this->lastName}";
    }

    public static function find(int $id): ?self {
        $sql = "
          SELECT
            driver_id   AS driverId,
            first_name  AS firstName,
            last_name   AS lastName,
            email       AS email,
            phone       AS phone
          FROM drivers WHERE driver_id = :id
        ";
        $stmt = Database::get()->prepare($sql);
        $stmt->execute([':id' => $id]);
        return $stmt->fetchObject(self::class) ?: null;
    }
}
```

### Vendors (fuel/service)

Schema shows `name`, `type`, `phone`, `city`, `state` with a uniqueness constraint. 

```php
<?php
// src/Vendor.php
final class Vendor {
    public int $vendorId;
    public string $name;
    public string $type;    // 'fuel' | 'service' | 'other'
    public ?string $phone = null;
    public ?string $city = null;
    public ?string $state = null;

    /** @return Vendor[] */
    public static function fuelStations(): array {
        $sql = "
          SELECT vendor_id AS vendorId, name, type, phone, city, state
          FROM vendors
          WHERE type = 'fuel'
          ORDER BY name
        ";
        $stmt = Database::get()->query($sql);
        return $stmt->fetchAll(PDO::FETCH_CLASS, self::class);
    }
}
```

### Fuel purchases

Columns include `vehicle_id`, `driver_id`, `vendor_id`, `purchase_datetime`, `quantity_gallons`, `unit_price`, `total_amount` (generated) etc. 

```php
<?php
// src/FuelPurchase.php
final class FuelPurchase {
    public int $fuelPurchaseId;
    public int $vehicleId;
    public ?int $driverId;
    public ?int $vendorId;
    public ?int $fuelCardId;
    public string $purchaseDatetime;
    public ?int $odometer;
    public ?string $fuelGrade;
    public float $quantityGallons;
    public float $unitPrice;
    public float $totalAmount;   // generated column in schema
    public string $paymentMethod;
    public ?string $receiptNumber;
    public ?string $notes;

    /** @return FuelPurchase[] */
    public static function forVehicle(int $vehicleId): array {
        $sql = "
          SELECT
            fuel_purchase_id  AS fuelPurchaseId,
            vehicle_id        AS vehicleId,
            driver_id         AS driverId,
            vendor_id         AS vendorId,
            fuel_card_id      AS fuelCardId,
            purchase_datetime AS purchaseDatetime,
            odometer          AS odometer,
            fuel_grade        AS fuelGrade,
            quantity_gallons  AS quantityGallons,
            unit_price        AS unitPrice,
            total_amount      AS totalAmount,
            payment_method    AS paymentMethod,
            receipt_number    AS receiptNumber,
            notes             AS notes
          FROM fuel_purchases
          WHERE vehicle_id = :vid
          ORDER BY purchase_datetime DESC
        ";
        $stmt = Database::get()->prepare($sql);
        $stmt->execute([':vid' => $vehicleId]);
        return $stmt->fetchAll(PDO::FETCH_CLASS, self::class);
    }
}
```

### Maintenance records

Includes a **generated** `total_cost` and foreign keys to vehicle/type/vendor. 

```php
<?php
// src/MaintenanceRecord.php
final class MaintenanceRecord {
    public int $maintenanceId;
    public int $vehicleId;
    public int $maintenanceTypeId;
    public ?int $vendorId;
    public string $serviceDate;
    public ?int $odometer;
    public float $laborCost;
    public float $partsCost;
    public float $tax;
    public float $otherFees;
    public float $totalCost;   // generated by DB
    public ?string $invoiceNumber;
    public ?string $description;

    /** @return MaintenanceRecord[] */
    public static function recent(int $limit = 10): array {
        $stmt = Database::get()->prepare("
          SELECT
            maintenance_id     AS maintenanceId,
            vehicle_id         AS vehicleId,
            maintenance_type_id AS maintenanceTypeId,
            vendor_id          AS vendorId,
            service_date       AS serviceDate,
            odometer           AS odometer,
            labor_cost         AS laborCost,
            parts_cost         AS partsCost,
            tax                AS tax,
            other_fees         AS otherFees,
            total_cost         AS totalCost,
            invoice_number     AS invoiceNumber,
            description        AS description
          FROM maintenance_records
          ORDER BY service_date DESC
          LIMIT :lim
        ");
        $stmt->bindValue(':lim', $limit, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_CLASS, self::class);
    }
}
```

### Odometer readings (for “latest odometer” lookup)

Columns: `vehicle_id`, `reading_date`, `odometer`, `source`… 

```php
<?php
// src/OdometerReading.php
final class OdometerReading {
    public int $readingId;
    public int $vehicleId;
    public string $readingDate;
    public int $odometer;
    public string $source;
    public ?string $notes;

    public static function latestForVehicle(int $vehicleId): ?self {
        $sql = "
          SELECT
            reading_id   AS readingId,
            vehicle_id   AS vehicleId,
            reading_date AS readingDate,
            odometer     AS odometer,
            source       AS source,
            notes        AS notes
          FROM odometer_readings
          WHERE vehicle_id = :vid
          ORDER BY reading_date DESC
          LIMIT 1
        ";
        $st = Database::get()->prepare($sql);
        $st->execute([':vid' => $vehicleId]);
        return $st->fetchObject(self::class) ?: null;
    }
}
```

---

## 3) Hydration demos (copy/paste runnable)

### A) List vehicles with their latest odometer

```php
<?php
require 'src/Database.php';
require 'src/Vehicle.php';
require 'src/OdometerReading.php';

$vehicles = Vehicle::all();
echo "<h3>Fleet</h3><ul>";
foreach ($vehicles as $v) {
    $latest = OdometerReading::latestForVehicle($v->vehicleId);
    $odoTxt = $latest ? number_format($latest->odometer) . " mi" : "n/a";
    echo "<li>" . htmlspecialchars($v->label(), ENT_QUOTES) . " — ODO: {$odoTxt}</li>";
}
echo "</ul>";
```

With the seed data (year-end readings plus fuel/maintenance inserts), each vehicle should show a sensible ODO.

### B) Recent fuel purchases for a vehicle

```php
<?php
require 'src/Database.php';
require 'src/FuelPurchase.php';

$purchases = FuelPurchase::forVehicle(1);
echo "<h3>Fuel — Vehicle #1</h3><ul>";
foreach ($purchases as $p) {
    echo "<li>" .
        htmlspecialchars($p->purchaseDatetime, ENT_QUOTES) .
        " — " . number_format($p->quantityGallons, 3) . " gal @ $" .
        number_format($p->unitPrice, 3) . " = $" .
        number_format($p->totalAmount, 2) .
        " (ODO " . (int)$p->odometer . ")</li>";
}
echo "</ul>";
```

You’ll see rows from **Jan/Feb 2025** in the sample data.

### C) Recent maintenance summary

```php
<?php
require 'src/Database.php';
require 'src/MaintenanceRecord.php';

$records = MaintenanceRecord::recent(5);
echo "<h3>Recent Maintenance</h3><ul>";
foreach ($records as $m) {
    echo "<li>{$m->serviceDate} — Vehicle {$m->vehicleId} — Invoice " .
         htmlspecialchars($m->invoiceNumber ?? 'n/a', ENT_QUOTES) .
         " — $" . number_format($m->totalCost, 2) . "</li>";
}
echo "</ul>";
```

The schema computes `total_cost` from cost parts (labor/parts/tax/fees).

---

## 4) Pattern for any other table (quick template)

Every time you add a new class, follow this pattern: list **camelCase** properties, write a **SELECT** that **aliases** every snake_case column, and hydrate with `fetchObject()` or `FETCH_CLASS`.

```php
final class VehicleAssignment {
    public int $assignmentId;
    public int $vehicleId;
    public int $driverId;
    public string $startDate;
    public ?string $endDate;
    public ?int $startOdometer;
    public ?int $endOdometer;
    public ?string $notes;

    /** @return VehicleAssignment[] */
    public static function forVehicle(int $vehicleId): array {
        $sql = "
          SELECT
            assignment_id AS assignmentId,
            vehicle_id    AS vehicleId,
            driver_id     AS driverId,
            start_date    AS startDate,
            end_date      AS endDate,
            start_odometer AS startOdometer,
            end_odometer   AS endOdometer,
            notes         AS notes
          FROM vehicle_assignments
          WHERE vehicle_id = :vid
          ORDER BY start_date DESC
        ";
        $st = Database::get()->prepare($sql);
        $st->execute([':vid' => $vehicleId]);
        return $st->fetchAll(PDO::FETCH_CLASS, self::class);
    }
}
```

(See schema for these columns.)

---

## 5) Why aliasing works (and alternatives)

* `fetchObject(Foo::class)`/`FETCH_CLASS` populates **public properties by name**. Using `AS propertyName` gives you a perfect snake→camel bridge with **zero post-processing**.
* If you want constructors to run **before** or **after** hydration, switch between:

  * `fetchAll(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, Foo::class)` (constructor first), or
  * `fetchAll(PDO::FETCH_CLASS, Foo::class)` (properties first; handy for post-casts in `__construct`).

---

## 6) Quick tests students can try (5–10 min)

1. Add a `findByVin(string $vin)` method to `Vehicle` (prepared statement; alias to camelCase).
2. Join `fuel_purchases` to `vendors` to display the **station name** next to each fill (remember vendor columns: `name`, `type`). 
3. Add a `latestFuel()` method on `Vehicle` that returns the most recent `FuelPurchase`.

---

## 7) Key takeaways

* Keep **one** PDO connection in a **static** property (`Database::get()`).
* Keep your **domain classes** small and focused (camelCase props).
* Always **alias** snake_case columns to camelCase in SELECTs for clean hydration.
* Prefer `prepare/execute` with parameters for any user input.
* Hydrate with `fetchObject()` or `FETCH_CLASS` for readable, testable code.
