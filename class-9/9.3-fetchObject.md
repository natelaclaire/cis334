---
layout: default
title: 9.3 Using fetchObject() to Hydrate Rows into PHP Objects (PDO)
nav_order: 3
---

# 9.3 Using `fetchObject()` to Hydrate Rows into PHP Objects (PDO)

## 0) What you’ll learn

Today we’ll use **`PDOStatement::fetchObject()`** to turn result rows into **instances of a class**. We’ll define a table, create a matching PHP class, and then hydrate objects directly from SQL.

---

## 1) Prep: sample table + seed data (MySQL or SQLite)

**MySQL schema**

```sql
CREATE TABLE IF NOT EXISTS books (
  id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  title VARCHAR(200) NOT NULL,
  author VARCHAR(120) NOT NULL,
  published_at DATE NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

INSERT INTO books (title, author, published_at) VALUES
  ('Clean Code', 'Robert C. Martin', '2008-08-01'),
  ('Design Patterns', 'Erich Gamma et al.', '1994-10-31'),
  ('Refactoring', 'Martin Fowler', '1999-07-08');
```

**SQLite schema (drop-in alternative)**

```sql
CREATE TABLE IF NOT EXISTS books (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT NOT NULL,
  author TEXT NOT NULL,
  published_at TEXT
);

INSERT INTO books (title, author, published_at) VALUES
  ('Clean Code', 'Robert C. Martin', '2008-08-01'),
  ('Design Patterns', 'Erich Gamma et al.', '1994-10-31'),
  ('Refactoring', 'Martin Fowler', '1999-07-08');
```

---

## 2) Connect with PDO

```php
<?php
// Choose one DSN:
$pdo = new PDO("mysql:host=db;dbname=mydb;charset=utf8mb4", "mariadb", "mariadb", [
  PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
  PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC, // default; fetchObject ignores this
  PDO::ATTR_EMULATE_PREPARES => false,
]);

// or SQLite
// $pdo = new PDO("sqlite:" . __DIR__ . "/example.sqlite");
// $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
```

---

## 3) Define a matching PHP class

### Option A — Simple, quick (public properties, no constructor)

```php
class Book {
    public $id;
    public $title;
    public $author;
    public $published_at;

    public function fullLabel(): string {
        return "{$this->title} — {$this->author} (" . ($this->published_at ?? "n/a") . ")";
    }
}
```

“`fetchObject(Book::class)` will instantiate `Book` and assign **columns to public properties with the same names**.

### Option B — Typed properties & casting in constructor (advanced)

PDO usually delivers values as **strings**. If you want strict typing, assign/cast in the constructor.

```php
class BookTyped {
    public int $id;
    public string $title;
    public string $author;
    public ?string $published_at;

    public function __construct() {
        // If properties are assigned before the constructor (see §6),
        // you can normalize/cast here:
        $this->id = (int)$this->id;
        $this->published_at = $this->published_at ?: null;
    }

    public function year(): ?int {
        return $this->published_at ? (int)substr($this->published_at, 0, 4) : null;
    }
}
```

---

## 4) Basic usage — one row at a time

```php
$stmt = $pdo->query("SELECT id, title, author, published_at FROM books ORDER BY id");

// stdClass (no class specified)
$first = $stmt->fetchObject();
echo $first->title, " by ", $first->author, "<br>";

// reset or re-run for class hydration:
$stmt = $pdo->query("SELECT id, title, author, published_at FROM books ORDER BY id");

// hydrate as Book objects
while ($book = $stmt->fetchObject(Book::class)) {
    echo $book->fullLabel(), "<br>";
}
```

**Key points to say**

* If no class is given, you get a **`stdClass`** where columns are properties.
* If you pass a class name, PDO hydrates **public** properties with **matching column names**.

---

## 5) Passing constructor args to `fetchObject()`

If your class constructor requires arguments, you can pass them as the second parameter.

```php
class BookWithCtx {
    public $id, $title, $author, $published_at;
    public function __construct(private string $context) {}
    public function label(): string { return "[{$this->context}] {$this->title}"; }
}

$stmt = $pdo->query("SELECT id, title, author, published_at FROM books");
while ($b = $stmt->fetchObject(BookWithCtx::class, ['catalog'])) {
    echo $b->label(), "<br>";
}
```

---

## 6) Constructor timing & alternatives (important nuance)

* With **`fetchObject()`**, PDO constructs the object and assigns columns to **public** properties.
* If you need **control over when the constructor runs vs when properties are filled**, use `fetchAll()` with **`PDO::FETCH_CLASS`** and (optionally) **`PDO::FETCH_PROPS_LATE`**:

```php
$stmt = $pdo->query("SELECT id, title, author, published_at FROM books");

// Properties before constructor (default):
$books = $stmt->fetchAll(PDO::FETCH_CLASS, BookTyped::class);

// Properties AFTER constructor (run constructor first, then assign):
// $books = $stmt->fetchAll(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, BookTyped::class);

foreach ($books as $b) {
    echo $b->year(), ": ", $b->title, "<br>";
}
```

Use **`FETCH_PROPS_LATE`** if you specifically want the constructor to run **before** PDO assigns properties (e.g., to set up defaults that shouldn’t be overwritten). If you prefer to **cast/normalize inside the constructor after props are set**, stick to the default (no `FETCH_PROPS_LATE`).

---

## 7) Mapping column names to different property names

If your column names don’t match property names, **alias them in SQL**.

```php
class BookView {
    public $bookId;
    public $title;
    public $author;
}

$stmt = $pdo->query("
  SELECT id AS bookId, title, author
  FROM books
");
while ($b = $stmt->fetchObject(BookView::class)) {
    echo "#{$b->bookId} — {$b->title}<br>";
}
```

---

## 8) Bulk hydration with `fetchAll(PDO::FETCH_CLASS)`

If you want the entire result set as objects in one go, use `fetchAll()`.

```php
$stmt = $pdo->query("SELECT id, title, author, published_at FROM books ORDER BY id");
$books = $stmt->fetchAll(PDO::FETCH_CLASS, Book::class);

foreach ($books as $book) {
    echo $book->fullLabel(), "<br>";
}
```

---

## 9) Pitfalls & best practices

* **Typed props vs stringy DB values**: cast in constructor or allow `?string`/`mixed`.
* **Visibility**: only **public** properties get hydrated automatically.
* **Large result sets**: prefer streaming (`while ($stmt->fetchObject(...))`) instead of `fetchAll()`.
* **Keep classes cohesive**: avoid dumping every column into one class; consider **view models** per screen.
* **Validation** still matters: hydration ≠ validation. Validate before writes; sanitize on output (`htmlspecialchars`).

---

## 10) Full, copy-paste demo

```php
<?php
// 1) Connect
$pdo = new PDO("mysql:host=db;dbname=mydb;charset=utf8mb4", "mariadb", "mariadb", [
  PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
  PDO::ATTR_EMULATE_PREPARES => false,
]);

// 2) Class (simple)
class Book {
    public $id;
    public $title;
    public $author;
    public $published_at;
    public function fullLabel(): string {
        return "{$this->title} — {$this->author} (" . ($this->published_at ?? "n/a") . ")";
    }
}

// 3) Query + hydrate
$stmt = $pdo->query("SELECT id, title, author, published_at FROM books ORDER BY id");

// Stream as objects
echo "<h3>Books</h3><ul>";
while ($book = $stmt->fetchObject(Book::class)) {
    echo "<li>" . htmlspecialchars($book->fullLabel(), ENT_QUOTES) . "</li>";
}
echo "</ul>";
```

---

## Closing

`fetchObject()` is a great bridge from relational rows to OO PHP. Start simple with public properties, and when you need stricter typing or constructor logic, switch to `FETCH_CLASS` (and `FETCH_PROPS_LATE` when appropriate).
