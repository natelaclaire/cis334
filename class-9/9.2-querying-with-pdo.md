---
layout: default
title: 9.2 Querying With PDO
nav_order: 2
---

# 9.2 Querying With PDO

## 0) Setup recap

We’re using **PDO** with PHP 8. Our connection uses `ERRMODE_EXCEPTION`, `FETCH_ASSOC`, and `EMULATE_PREPARES=false`. If you have the `pdo_starter_pack`, you’re ready to follow along.

```php
<?php
$dsn  = "mysql:host=db;dbname=mydb;charset=utf8mb4";  // swap to SQLite DSN below if desired
$user = "mariadb";
$pass = "mariadb";
$pdo  = new PDO($dsn, $user, $pass, [
  PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
  PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
  PDO::ATTR_EMULATE_PREPARES   => false,
]);
```

*(SQLite swap later: `$pdo = new PDO("sqlite:" . __DIR__ . "/example.sqlite"); $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);`)*

---

## 1) Simple SELECT (no user input) — `query()`

If your SQL has **no user input**, `query()` is fine. Fetch with `fetchAll()` to load the entire result set into an array or iterate row-by-row.

```php
// Example: list students alphabetical by last name
$sql  = "SELECT id, first_name, last_name FROM students ORDER BY last_name";
$rows = $pdo->query($sql)->fetchAll();   // default FETCH_ASSOC from options

foreach ($rows as $r) {
    echo "{$r['id']} — {$r['last_name']}, {$r['first_name']}<br>";
}
```

**Instructor tip:** For large result sets, iterate the statement instead of `fetchAll()` to save memory:

```php
$stmt = $pdo->query($sql);
foreach ($stmt as $row) {
    // each $row is associative
}
```

---

## 2) Prepared SELECT (with user input) — positional vs named

The moment **user input** is involved, use **prepared statements**. This prevents SQL injection by sending the SQL and the data **separately**.

### A) Positional placeholders `?`

Just like MySQLi's prepared statements, PDO prepared statements support positional placeholders.

```php
$status = $_GET['status'] ?? 'active';
$minId  = (int)($_GET['min'] ?? 1);

$stmt = $pdo->prepare("
  SELECT id, username, email
  FROM users
  WHERE status = ? AND id >= ?
  ORDER BY id
");
$stmt->execute([$status, $minId]);
$rows = $stmt->fetchAll();
```

### B) Named placeholders `:name`

PDO also adds named placeholders, which makes them much more flexible and easier to understand.

```php
$stmt = $pdo->prepare("
  SELECT id, username, email
  FROM users
  WHERE status = :status AND id >= :min
  ORDER BY id
");
$stmt->execute([':status' => $status, ':min' => $minId]);
$rows = $stmt->fetchAll(); // fetch all results into an array
```

**Quick fetch variants**

* One row: `$row = $stmt->fetch();`
* Single value: `$count = $pdo->query("SELECT COUNT(*) FROM users")->fetchColumn();` (can add a 0-indexed column number as a parameter if the query is returning multiple columns)

---

## 3) INSERT securely (single & batch) — `execute()` + `lastInsertId()`

### A) Single row

```php
$stmt = $pdo->prepare("
  INSERT INTO users (username, email, status)
  VALUES (:u, :e, :s)
");
$stmt->execute([
  ':u' => 'maria',
  ':e' => 'maria@example.com',
  ':s' => 'active',
]);

$newId = $pdo->lastInsertId(); // works with AUTO_INCREMENT
echo "Inserted user id: " . htmlspecialchars($newId);
```

### B) Batch insert (loop safely)

```php
$data = [
  ['ava',  'ava@example.com',  'active'],
  ['joel', 'joel@example.com', 'inactive'],
  ['mina', 'mina@example.com', 'active'],
];

$stmt = $pdo->prepare("INSERT INTO users (username, email, status) VALUES (?, ?, ?)");
foreach ($data as [$u, $e, $s]) {
    $stmt->execute([$u, $e, $s]);     // still parameterized each time
}
```

**Instructor tip:** For many rows, wrap in a **transaction** to speed things up and ensure all-or-nothing (covered briefly in §7).

---

## 4) UPDATE and DELETE with parameters

```php
// UPDATE
$stmt = $pdo->prepare("UPDATE users SET status = :s WHERE id = :id");
$stmt->execute([':s' => 'active', ':id' => 5]);
echo "Rows changed: " . $stmt->rowCount();

// DELETE
$stmt = $pdo->prepare("DELETE FROM logs WHERE created_at < (NOW() - INTERVAL 30 DAY)");
$stmt->execute();
echo "Rows deleted: " . $stmt->rowCount();
```

`rowCount()` returns affected rows for UPDATE/DELETE. For SELECT, its behavior is driver-dependent; prefer `COUNT(*)` in SQL when you need counts.

---

## 5) Binding types & tricky parameters (LIMIT, NULL, dates)

PDO infers most types, but sometimes you must specify them.

### A) `LIMIT` must be an integer literal on some DBs

```php
$limit = (int)($_GET['limit'] ?? 5);
$stmt  = $pdo->prepare("
  SELECT id, first_name, last_name
  FROM students
  ORDER BY id
  LIMIT :lim
");
$stmt->bindValue(':lim', $limit, PDO::PARAM_INT);  // important!
$stmt->execute();
$rows = $stmt->fetchAll();
```

### B) Handling `NULL`

```php
$stmt = $pdo->prepare("UPDATE users SET middle_name = :m WHERE id = :id");
$mid  = null; // store SQL NULL
$stmt->bindValue(':m', $mid, PDO::PARAM_NULL);
$stmt->bindValue(':id', 7, PDO::PARAM_INT);
$stmt->execute();
```

### C) Booleans & dates

* Booleans: bind as `PDO::PARAM_BOOL` if driver supports it, else use 0/1.
* Dates: pass ISO strings (e.g., `'2025-10-21 09:30:00'`) and let the DB column type (DATE/DATETIME/TIMESTAMP) handle it.

---

## 6) Fetch modes & output options

```php
$stmt = $pdo->query("SELECT id, first_name FROM students LIMIT 3");

// assoc (default via options)
$row = $stmt->fetch(PDO::FETCH_ASSOC);

// numeric
$row = $stmt->fetch(PDO::FETCH_NUM);

// object (stdClass)
$row = $stmt->fetch(PDO::FETCH_OBJ);  // $row->first_name
```

Default to `FETCH_ASSOC` for clarity. Use objects if you prefer property access.

---

## 7) (Brief) Transactions for grouped operations

When multiple statements must succeed or fail together, use a transaction.

```php
try {
    $pdo->beginTransaction();

    $pdo->prepare("UPDATE accounts SET balance = balance - ? WHERE id = ?")
        ->execute([50.00, 1]);

    $pdo->prepare("UPDATE accounts SET balance = balance + ? WHERE id = ?")
        ->execute([50.00, 2]);

    $pdo->commit();
} catch (Throwable $e) {
    if ($pdo->inTransaction()) { $pdo->rollBack(); }
    // Log $e->getMessage() server-side; show safe message to user
}
```

---

## 8) Switching MySQL ↔ SQLite

With PDO, switching DBs is mostly changing the **DSN**. The query code above remains the same.

```php
// MySQL
$pdo = new PDO("mysql:host=127.0.0.1;dbname=mydb;charset=utf8mb4", "dbuser", "dbpass", $options);

// SQLite
$pdo = new PDO("sqlite:" . __DIR__ . "/example.sqlite");
$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
```

---

## 9) Common pitfalls

* **Interpolating user input into SQL** → ❌ Never. Always `prepare()` + `execute()`.
* **Forgetting `PDO::PARAM_INT` for LIMIT** on strict drivers.
* **Relying on `rowCount()` for SELECT** → use `COUNT(*)` in SQL.
* **Not setting `ERRMODE_EXCEPTION`** → silent failures. Turn exceptions on.
* **Assuming SQL portability** → PDO unifies API, not SQL dialects; test queries when switching engines.

---

## Closing thoughts

You can now read and write data safely with PDO. In the next lesson, we'll explore how to hydrate MySQL rows into PHP object using PDO, making it easy for you to take full advantage of encapsulation with data from a database.
