---
layout: default
title: 9.2 Querying With PDO
nav_order: 2
---

# 9.2 Querying With PDO

## 0) Setup recap

We’re using **PDO** with PHP 8. Our connection uses `ERRMODE_EXCEPTION`, `FETCH_ASSOC`, and `EMULATE_PREPARES=false`. If you have the `pdo_starter_pack`, you’re ready to follow along.

```php
<?php
$dsn  = "mysql:host=db;dbname=mydb;charset=utf8mb4";  // swap to SQLite DSN below if desired
$user = "mariadb";
$pass = "mariadb";
$pdo  = new PDO($dsn, $user, $pass, [
  PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
  PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
  PDO::ATTR_EMULATE_PREPARES   => false,
]);
```

*(SQLite swap later: `$pdo = new PDO("sqlite:" . __DIR__ . "/example.sqlite"); $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);`)*

---

## 1) Simple SELECT (no user input) — `query()`

If your SQL has **no user input**, `query()` is fine. Fetch with `fetchAll()` to load the entire result set into an array or iterate row-by-row.

```php
// Example: list vendors alphabetical by type and name
$sql  = "SELECT vendor_id, name, type FROM vendors ORDER BY type, name";
$rows = $pdo->query($sql)->fetchAll();   // default FETCH_ASSOC from options

foreach ($rows as $r) {
    echo "{$r['vendor_id']} — {$r['name']}, {$r['type']}<br>";
}
```

**Instructor tip:** For large result sets, iterate the statement instead of `fetchAll()` to save memory:

```php
$stmt = $pdo->query($sql);
foreach ($stmt as $row) {
    // each $row is associative
}
```

---

## 2) Prepared SELECT (with user input) — positional vs named

The moment **user input** is involved, use **prepared statements**. This prevents SQL injection by sending the SQL and the data **separately**.

### A) Positional placeholders `?`

Just like MySQLi's prepared statements, PDO prepared statements support positional placeholders.

```php
$active = $_GET['active'] ?? '1'; // e.g., '1' for active or '0' for inactive
$minId  = (int)($_GET['min'] ?? 1);

$stmt = $pdo->prepare("
  SELECT driver_id, first_name, last_name, email
  FROM drivers
  WHERE active = ? AND id >= ?
  ORDER BY driver_id
");
$stmt->execute([$active, $minId]);
$rows = $stmt->fetchAll();
```

### B) Named placeholders `:name`

PDO also adds named placeholders, which makes them much more flexible and easier to understand.

```php
$stmt = $pdo->prepare("
  SELECT driver_id, first_name, last_name, email
  FROM drivers
  WHERE active = :active AND driver_id >= :min
  ORDER BY driver_id
");
$stmt->execute([':active' => $active, ':min' => $minId]);
$rows = $stmt->fetchAll(); // fetch all results into an array
```

**Quick fetch variants**

* One row: `$row = $stmt->fetch();`
* Single value: `$count = $pdo->query("SELECT COUNT(*) FROM drivers")->fetchColumn();` (can add a 0-indexed column number as a parameter if the query is returning multiple columns)

---

## 3) INSERT securely (single & batch) — `execute()` + `lastInsertId()`

### A) Single row

```php
$stmt = $pdo->prepare("
  INSERT INTO vehicle_models (make, model)
  VALUES (:make, :model)
");
$stmt->execute([
  ':make' => 'Tesla',
  ':model' => 'Cybertruck',
]);

$newId = $pdo->lastInsertId(); // works with AUTO_INCREMENT
echo "Inserted vehicle model id: " . htmlspecialchars($newId);
```

### B) Batch insert (loop safely)

```php
$data = [
  ['Kia',  'Soul'],
  ['Mercury', 'Mountaineer'],
  ['Honda', 'Civic'],
  ['Ford',  'F-150'],
];

$stmt = $pdo->prepare("INSERT INTO vehicle_models (make, model) VALUES (?, ?)");
foreach ($data as [$make, $model]) {
    $stmt->execute([$make, $model]);     // still parameterized each time
}
```

**Instructor tip:** For many rows, wrap in a **transaction** to speed things up and ensure all-or-nothing (covered briefly in §7).

---

## 4) UPDATE and DELETE with/without parameters

```php
// UPDATE
$stmt = $pdo->prepare("UPDATE fuel_cards SET active = :a WHERE fuel_card_id = :id");
$stmt->execute([':a' => '0', ':id' => 2]);
echo "Rows changed: " . $stmt->rowCount();

// DELETE
$stmt = $pdo->prepare("DELETE FROM odometer_readings WHERE reading_date < (NOW() - INTERVAL 365 DAY)");
$stmt->execute();
echo "Rows deleted: " . $stmt->rowCount();
```

`rowCount()` returns affected rows for UPDATE/DELETE. For SELECT, its behavior is driver-dependent; prefer `COUNT(*)` in SQL when you need counts.

---

## 5) Binding types & tricky parameters (LIMIT, NULL, dates)

PDO infers most types, but sometimes you must specify them.

### A) `LIMIT` must be an integer literal on some DBs

```php
$limit = (int)($_GET['limit'] ?? 5);
$stmt  = $pdo->prepare("
  SELECT vin, license_plate
  FROM vehicles
  ORDER BY vehicle_id
  LIMIT :lim
");
$stmt->bindValue(':lim', $limit, PDO::PARAM_INT);  // important!
$stmt->execute();
$rows = $stmt->fetchAll();
```

### B) Handling `NULL`

```php
$stmt = $pdo->prepare("UPDATE users SET middle_name = :m WHERE id = :id");
$mid  = null; // store SQL NULL
$stmt->bindValue(':m', $mid, PDO::PARAM_NULL);
$stmt->bindValue(':id', 7, PDO::PARAM_INT);
$stmt->execute();
```

### C) Booleans & dates

* Booleans: bind as `PDO::PARAM_BOOL` if driver supports it, else use 0/1.
* Dates: pass ISO strings (e.g., `'2025-10-21 09:30:00'`) and let the DB column type (DATE/DATETIME/TIMESTAMP) handle it.

---

## 6) Fetch modes & output options

```php
$stmt = $pdo->query("SELECT vin, license_plate FROM vehicles LIMIT 3");

// assoc (default via options)
$row = $stmt->fetch(PDO::FETCH_ASSOC);

// numeric
$row = $stmt->fetch(PDO::FETCH_NUM);

// object (stdClass)
$row = $stmt->fetch(PDO::FETCH_OBJ);  // $row->first_name
```

Default to `FETCH_ASSOC` for clarity. Use objects if you prefer property access.

---

## 7) (Brief) Transactions for grouped operations

When multiple statements must succeed or fail together, use a transaction.

```php
try {
    $pdo->beginTransaction();

    $pdo->prepare("UPDATE accounts SET balance = balance - ? WHERE id = ?")
        ->execute([50.00, 1]);

    $pdo->prepare("UPDATE accounts SET balance = balance + ? WHERE id = ?")
        ->execute([50.00, 2]);

    $pdo->commit();
} catch (Throwable $e) {
    if ($pdo->inTransaction()) { $pdo->rollBack(); }
    // Log $e->getMessage() server-side; show safe message to user
}
```

---

## 8) Switching MySQL ↔ SQLite

With PDO, switching DBs is mostly changing the **DSN**. The query code above remains the same.

```php
// MySQL
$pdo = new PDO("mysql:host=127.0.0.1;dbname=mydb;charset=utf8mb4", "dbuser", "dbpass", $options);

// SQLite
$pdo = new PDO("sqlite:" . __DIR__ . "/example.sqlite");
$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
```

---

## 9) Common pitfalls

* **Interpolating user input into SQL** → ❌ Never. Always `prepare()` + `execute()`.
* **Forgetting `PDO::PARAM_INT` for LIMIT** on strict drivers.
* **Relying on `rowCount()` for SELECT** → use `COUNT(*)` in SQL.
* **Not setting `ERRMODE_EXCEPTION`** → silent failures. Turn exceptions on.
* **Assuming SQL portability** → PDO unifies API, not SQL dialects; test queries when switching engines.

---

## Closing thoughts

You can now read and write data safely with PDO. In the next lesson, we'll explore how to hydrate MySQL rows into PHP object using PDO, making it easy for you to take full advantage of encapsulation with data from a database.
