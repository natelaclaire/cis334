---
layout: default
title: 9.1 Introduction to PHP Data Objects (PDO)
nav_order: 1
---

# 9.1 Introduction to PHP Data Objects (PDO)

## **[Opening Scene: Course title card]**

**On screen:** “CIS 334 — Working with PDO in PHP”
**Narration:**

> In this lesson, we’re going to introduce **PHP Data Objects**, or **PDO** — a modern, flexible way to connect PHP to different types of databases.
>
> If you’ve been following along with our MySQLi lessons, PDO will feel familiar, but it’s even more powerful and portable.

---

### **[Scene 2: Why PDO?]**

**On screen:** “Why use PDO?”
**Narration:**

> PDO stands for **PHP Data Objects**, and it’s a **database abstraction layer** — that means it provides one consistent API for many database systems.
>
> Whether your site uses **MySQL**, **PostgreSQL**, **SQLite**, or **SQL Server**, the same PDO methods work. You just change the **Data Source Name**, or **DSN**, when connecting.

> So instead of learning a new set of functions for every database, PDO gives you **one unified interface**.

---

### **[Scene 3: The Benefits of PDO]**

**On screen:** “Key Benefits of PDO”
**Narration:**

> Here are some of the main advantages of PDO:

1. **Portability.** You can switch databases just by changing your connection string.
2. **Security.** It fully supports **prepared statements**, protecting you from SQL injection.
3. **Consistency.** All databases share the same methods for connecting, querying, binding parameters, and fetching results.
4. **Error handling with exceptions.** PDO can throw exceptions, so your code fails gracefully instead of silently.
5. **Flexibility.** You can configure fetch modes, control transactions, and manage connections in an object-oriented way.

> In other words, PDO simplifies database programming while keeping your applications secure and future-proof.

---

### **[Scene 4: The Downsides (briefly)]**

**On screen:** “PDO Limitations”
**Narration:**

> Now, PDO isn’t perfect. There are a few limitations to be aware of:

1. **Not all vendor-specific features are exposed.** For example, some MySQL-only features like `multi_query()` or certain metadata functions aren’t available through PDO.
2. **It’s slightly slower** for single, simple queries — although this difference is usually negligible.
3. **SQL portability still depends on you.** While PDO’s API is consistent, your SQL syntax might still differ between databases.

> So, think of PDO as giving you a *common toolkit*, but not necessarily one-size-fits-all SQL.

---

### **[Scene 5: Setting up a PDO connection]**

**On screen:** Code editor view showing connection setup.
**Narration:**

> Let’s look at how to create a PDO connection.
>
> We’ll start with a MySQL database.

```php
<?php
$host = '127.0.0.1';
$db   = 'mydb';
$user = 'dbuser';
$pass = 'dbpass';
$dsn  = "mysql:host=$host;dbname=$db;charset=utf8mb4";

$options = [
    PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION, // throw exceptions
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,       // associative arrays
    PDO::ATTR_EMULATE_PREPARES   => false,                  // use native prepares
];

try {
    $pdo = new PDO($dsn, $user, $pass, $options);
    echo "Connected successfully to MySQL!";
} catch (PDOException $e) {
    die("Connection failed: " . $e->getMessage());
}
```

> Here’s what’s happening:
>
> * We build a **DSN** string that defines which database driver to use (`mysql:`), where to connect, and which database to open.
> * We pass an array of **options** to configure error handling and fetch style.
> * The `PDO` constructor creates our connection object.
> * And if something goes wrong, `PDOException` provides a clear, catchable error.

---

### **[Scene 6: Switching databases (MySQL → SQLite)]**

**On screen:** “Switching from MySQL to SQLite”
**Narration:**

> Now here’s where PDO really shines — switching database engines is easy.
>
> Suppose we want to use SQLite instead of MySQL, maybe for a small local project or a test environment.
>
> All we have to do is change the DSN line and remove the username and password:

```php
<?php
// SQLite example
$dsn = "sqlite:" . __DIR__ . "/example.sqlite";

try {
    $pdo = new PDO($dsn);
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    echo "Connected successfully to SQLite!";
} catch (PDOException $e) {
    die("Connection failed: " . $e->getMessage());
}
```

> Notice that we didn’t change how we create the PDO object or how we handle errors.
>
> The rest of our code — prepared statements, fetching results, transactions — will work exactly the same way.

> That’s the **beauty of PDO**: one API, many databases.

---

### **[Scene 7: Quick summary]**

**On screen:** “PDO in a Nutshell”
**Narration:**

> To wrap up:
>
> * **PDO** is your go-to database interface for modern PHP.
> * It supports **secure prepared statements**, **exception-based error handling**, and **cross-database portability**.
> * It’s easy to switch from **MySQL** to **SQLite** (or others) by changing just your DSN.
> * While PDO doesn’t expose every vendor-specific feature, it’s the safest, most flexible way to work with databases in PHP 8 and beyond.

---

### **[Scene 8: Closing slide]**

**On screen:** “Next in this module: Running Queries and Using Prepared Statements in PDO”
**Narration:**

> In our next video, we’ll build on this foundation — running queries, inserting data, and using prepared statements securely with PDO.
>
> See you there!
